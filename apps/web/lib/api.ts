/**
 * Generated by orval v7.9.0 ğŸº
 * Do not edit manually.
 * Groble API
 * Groble ì„œë¹„ìŠ¤ì˜ API ëª…ì„¸ì„œì…ë‹ˆë‹¤.
 * OpenAPI spec version: v1.0.0
 */
import { customFetch } from "./custom-fetch";
export interface Accessor {
  id?: number;
  email?: string;
  roles?: string[];
  userType?: string;
  accountType?: string;
  integratedAccount?: boolean;
  buyer?: boolean;
  socialAccount?: boolean;
  anonymous?: boolean;
  seller?: boolean;
  userId?: number;
  authenticated?: boolean;
}

export interface UserTypeRequest {
  /** @pattern ^(SELLER|BUYER)$ */
  userType: string;
}

/**
 * ì—ëŸ¬ ìƒì„¸ ì •ë³´
 */
export interface ErrorDetail {
  code?: string;
  message?: string;
  exception?: string;
  field?: string;
  trace?: string;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type UserSwitchRoleApiResponseStatus =
  (typeof UserSwitchRoleApiResponseStatus)[keyof typeof UserSwitchRoleApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSwitchRoleApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

/**
 * ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ)
 */
export type UserSwitchRoleApiResponseData = { [key: string]: unknown };

export interface UserSwitchRoleApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: UserSwitchRoleApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  /** ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ) */
  data?: UserSwitchRoleApiResponseData;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type GrobleResponseStatus =
  (typeof GrobleResponseStatus)[keyof typeof GrobleResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GrobleResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

/**
 * ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ)
 */
export type GrobleResponseData = { [key: string]: unknown };

/**
 * ê³µí†µ ì‘ë‹µ í˜•ì‹
 */
export interface GrobleResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: GrobleResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  /** ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ) */
  data?: GrobleResponseData;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type FileUploadApiResponseStatus =
  (typeof FileUploadApiResponseStatus)[keyof typeof FileUploadApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FileUploadApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

export interface FileUploadApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: FileUploadApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  data?: FileUploadResponse;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ)
 */
export interface FileUploadResponse {
  /** ì›ë³¸ íŒŒì¼ ì´ë¦„ */
  originalFileName?: string;
  /** íŒŒì¼ URL */
  fileUrl?: string;
  /** íŒŒì¼ MIME íƒ€ì… */
  contentType?: string;
  /** íŒŒì¼ ì €ì¥ ê²½ë¡œ */
  directory?: string;
}

export type TermsAgreementRequestTermsTypesItem =
  (typeof TermsAgreementRequestTermsTypesItem)[keyof typeof TermsAgreementRequestTermsTypesItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TermsAgreementRequestTermsTypesItem = {
  AGE_POLICY: "AGE_POLICY",
  PRIVACY_POLICY: "PRIVACY_POLICY",
  SERVICE_TERMS_POLICY: "SERVICE_TERMS_POLICY",
  SELLER_TERMS_POLICY: "SELLER_TERMS_POLICY",
  MARKETING_POLICY: "MARKETING_POLICY",
} as const;

export interface TermsAgreementRequest {
  termsTypes: TermsAgreementRequestTermsTypesItem[];
}

export interface AdvertisingAgreementRequest {
  agreed: boolean;
}

/**
 * ë©”ì´ì»¤ ì•½ê´€ ë™ì˜ ì •ë³´
 */
export interface MakerTermsAgreementRequest {
  /** ë©”ì´ì»¤ ì´ìš©ì•½ê´€ ë™ì˜ ì—¬ë¶€ */
  makerTermsAgreement: boolean;
}

/**
 * ì„œë¹„ìŠ¤ ì˜µì…˜ ëª©ë¡ (contentTypeì´ COACHINGì¸ ê²½ìš°)
 */
export interface CoachingOptionRegisterRequest {
  /** ì˜µì…˜ ì´ë¦„ */
  name: string;
  /** ì˜µì…˜ ì„¤ëª… */
  description: string;
  /**
   * ê°€ê²©
   * @minimum 0
   */
  price: number;
}

export interface ContentRegisterRequest {
  /** ì½˜í…ì¸  ID */
  contentId?: number;
  /**
   * ì½˜í…ì¸  ì´ë¦„
   * @minLength 0
   * @maxLength 30
   */
  title: string;
  /**
   * ì½˜í…ì¸  ìœ í˜•
   * @pattern ^(COACHING|DOCUMENT)$
   */
  contentType: string;
  /** ì¹´í…Œê³ ë¦¬ ID */
  categoryId: string;
  /** ì¸ë„¤ì¼ ì´ë¯¸ì§€ URL */
  thumbnailUrl: string;
  /** ì„œë¹„ìŠ¤ ì˜µì…˜ ëª©ë¡ (contentTypeì´ COACHINGì¸ ê²½ìš°) */
  coachingOptions?: CoachingOptionRegisterRequest[];
  /** ë¬¸ì„œ ì˜µì…˜ ëª©ë¡ (contentTypeì´ DOCUMENTì¸ ê²½ìš°) */
  documentOptions?: DocumentOptionRegisterRequest[];
  /** ì½˜í…ì¸  ì†Œê°œ */
  contentIntroduction?: string;
  /** ì„œë¹„ìŠ¤ íƒ€ê²Ÿ */
  serviceTarget: string;
  /** ì œê³µ ì ˆì°¨ */
  serviceProcess: string;
  /** ë©”ì´ì»¤ ì†Œê°œ */
  makerIntro: string;
}

/**
 * ë¬¸ì„œ ì˜µì…˜ ëª©ë¡ (contentTypeì´ DOCUMENTì¸ ê²½ìš°)
 */
export interface DocumentOptionRegisterRequest {
  /** ì˜µì…˜ ì´ë¦„ */
  name: string;
  /** ì˜µì…˜ ì„¤ëª… */
  description: string;
  /**
   * ê°€ê²©
   * @minimum 0
   */
  price: number;

  /** ìë£Œ íŒŒì¼ URL */
  documentFileUrl?: string;
  /** ìë£Œ ë§í¬ URL */
  documentLinkUrl?: string;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type ContentRegisterApiResponseStatus =
  (typeof ContentRegisterApiResponseStatus)[keyof typeof ContentRegisterApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ContentRegisterApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

export interface ContentRegisterApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: ContentRegisterApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  data?: ContentResponse;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ)
 */
export interface ContentResponse {
  /** ì½˜í…ì¸  ID */
  id?: number;
  /** ì½˜í…ì¸  ì´ë¦„ */
  title?: string;
  /** ì½˜í…ì¸  ìœ í˜• [COACHING - ì„œë¹„ìŠ¤], [DOCUMENT - ìë£Œ] */
  contentType?: string;
  /** ì¹´í…Œê³ ë¦¬ ID */
  categoryId?: string;
  /** ì¸ë„¤ì¼ ì´ë¯¸ì§€ URL */
  thumbnailUrl?: string;
  /** ì½˜í…ì¸  ìƒíƒœ */
  status?: string;
  /** ì˜µì…˜ ëª©ë¡ */
  options?: OptionResponse[];
  /** ì½˜í…ì¸  ì†Œê°œ */
  contentIntroduction?: string;
  /** ì½˜í…ì¸  ìƒì„¸ ì´ë¯¸ì§€ URL ëª©ë¡ */
  contentDetailImageUrls?: string[];
  /** ì„œë¹„ìŠ¤ íƒ€ê²Ÿ */
  serviceTarget?: string;
  /** ì œê³µ ì ˆì°¨ */
  serviceProcess?: string;
  /** ë©”ì´ì»¤ ì†Œê°œ */
  makerIntro?: string;
}

/**
 * ì˜µì…˜ ëª©ë¡
 */
export interface OptionResponse {
  /** ì˜µì…˜ ID */
  id?: number;
  /** ì˜µì…˜ ì´ë¦„ */
  name?: string;
  /** ì˜µì…˜ ì„¤ëª… */
  description?: string;
  /** ê°€ê²© */
  price?: number;

  /** ë¬¸ì„œ íŒŒì¼ URL */
  documentFileUrl?: string;
  /** ìë£Œ ë§í¬ URL */
  documentLinkUrl?: string;
}

/**
 * ì„œë¹„ìŠ¤ ì˜µì…˜ ëª©ë¡ (contentTypeì´ COACHINGì¸ ê²½ìš°)
 */
export interface CoachingOptionDraftRequest {
  /** ì˜µì…˜ ì´ë¦„ */
  name?: string;
  /** ì˜µì…˜ ì„¤ëª… */
  description?: string;
  /**
   * ê°€ê²©
   * @minimum 0
   */
  price?: number;
}

export interface ContentDraftRequest {
  /** ì½˜í…ì¸  ID */
  contentId?: number;
  /**
   * ì½˜í…ì¸  ì´ë¦„
   * @minLength 0
   * @maxLength 30
   */
  title?: string;
  /**
   * ì½˜í…ì¸  ìœ í˜•
   * @pattern ^(COACHING|DOCUMENT)$
   */
  contentType?: string;
  /** ì¹´í…Œê³ ë¦¬ ID */
  categoryId?: string;
  /** ì¸ë„¤ì¼ ì´ë¯¸ì§€ URL */
  thumbnailUrl?: string;
  /** ì„œë¹„ìŠ¤ ì˜µì…˜ ëª©ë¡ (contentTypeì´ COACHINGì¸ ê²½ìš°) */
  coachingOptions?: CoachingOptionDraftRequest[];
  /** ë¬¸ì„œ ì˜µì…˜ ëª©ë¡ (contentTypeì´ DOCUMENTì¸ ê²½ìš°) */
  documentOptions?: DocumentOptionDraftRequest[];
  /** ì½˜í…ì¸  ì†Œê°œ */
  contentIntroduction?: string;
  /** ì½˜í…ì¸  ìƒì„¸ ì´ë¯¸ì§€ URL ëª©ë¡ */
  contentDetailImageUrls?: string[];
  /** ì„œë¹„ìŠ¤ íƒ€ê²Ÿ */
  serviceTarget?: string;
  /** ì œê³µ ì ˆì°¨ */
  serviceProcess?: string;
  /** ë©”ì´ì»¤ ì†Œê°œ */
  makerIntro?: string;
}

/**
 * ë¬¸ì„œ ì˜µì…˜ ëª©ë¡ (contentTypeì´ DOCUMENTì¸ ê²½ìš°)
 */
export interface DocumentOptionDraftRequest {
  /** ì˜µì…˜ ì´ë¦„ */
  name?: string;
  /** ì˜µì…˜ ì„¤ëª… */
  description?: string;
  /**
   * ê°€ê²©
   * @minimum 0
   */
  price?: number;

  /** ìë£Œ íŒŒì¼ URL */
  documentFileUrl?: string;
  /** ìë£Œ ë§í¬ URL */
  documentLinkUrl?: string;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type ContentDraftApiResponseStatus =
  (typeof ContentDraftApiResponseStatus)[keyof typeof ContentDraftApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ContentDraftApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

export interface ContentDraftApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: ContentDraftApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  data?: ContentResponse;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

export interface UpdateContentScrapStateRequest {
  /** ìŠ¤í¬ë© ìƒíƒœ ë³€ê²½ ì—¬ë¶€ (true : ìŠ¤í¬ë©ëœ ìƒíƒœë¡œ ë³€ê²½ë©ë‹ˆë‹¤. false : ìŠ¤í¬ë© ì·¨ì†Œ ìƒíƒœë¡œ ë³€ê²½ë©ë‹ˆë‹¤.) */
  changeScrapValue?: boolean;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type UpdateContentScrapStateApiResponseStatus =
  (typeof UpdateContentScrapStateApiResponseStatus)[keyof typeof UpdateContentScrapStateApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateContentScrapStateApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

export interface UpdateContentScrapStateApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: UpdateContentScrapStateApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  data?: UpdateContentScrapStateResponse;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ)
 */
export interface UpdateContentScrapStateResponse {
  /** ì½˜í…ì¸  ID */
  contentId?: number;
  /** ì½˜í…ì¸  ìŠ¤í¬ë© ìƒíƒœ (true : ìŠ¤í¬ë©ëœ ìƒíƒœë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤. false : ìŠ¤í¬ë© ì·¨ì†Œ ìƒíƒœë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.) */
  isContentScrap?: boolean;
}

/**
 * ì˜µì…˜ íƒ€ì…
 */
export type CreateOrderRequestOptionType =
  (typeof CreateOrderRequestOptionType)[keyof typeof CreateOrderRequestOptionType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateOrderRequestOptionType = {
  COACHING_OPTION: "COACHING_OPTION",
  DOCUMENT_OPTION: "DOCUMENT_OPTION",
} as const;

/**
 * ì£¼ë¬¸ ìƒì„± ìš”ì²­
 */
export interface CreateOrderRequest {
  /** ì½˜í…ì¸  ID */
  contentId: number;
  /** ì˜µì…˜ ID */
  optionId?: number;
  /** ì˜µì…˜ íƒ€ì… */
  optionType?: CreateOrderRequestOptionType;
  /** ì¿ í° ì½”ë“œ (ì„ íƒì‚¬í•­) */
  couponCode?: string;
}

export interface ContentExamineRequest {
  /** ì‹¬ì‚¬ ì•¡ì…˜ (APPROVE: ìŠ¹ì¸, REJECT: ë°˜ë ¤) */
  action?: string;
  /** ë°˜ë ¤ ì‚¬ìœ  (ë°˜ë ¤ ì‹œì—ë§Œ í•„ìš”) */
  rejectReason?: string;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type ContentExamineApiResponseStatus =
  (typeof ContentExamineApiResponseStatus)[keyof typeof ContentExamineApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ContentExamineApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

/**
 * ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ)
 */
export type ContentExamineApiResponseData = { [key: string]: unknown };

export interface ContentExamineApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: ContentExamineApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  /** ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ) */
  data?: ContentExamineApiResponseData;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type MultipleFilesUploadApiResponseStatus =
  (typeof MultipleFilesUploadApiResponseStatus)[keyof typeof MultipleFilesUploadApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MultipleFilesUploadApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

export interface MultipleFilesUploadApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: MultipleFilesUploadApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  /** ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ) */
  data?: FileUploadResponse[];
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type MultiFileUploadApiResponseStatus =
  (typeof MultiFileUploadApiResponseStatus)[keyof typeof MultiFileUploadApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MultiFileUploadApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

/**
 * ì—¬ëŸ¬ ê°œ íŒŒì¼ ì—…ë¡œë“œ ì‘ë‹µ
 */
export interface MultiFileUploadApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: MultiFileUploadApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  /** ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ) */
  data?: FileUploadResponse[];
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * íƒˆí‡´ ì‚¬ìœ 
 */
export type UserWithdrawalRequestReason =
  (typeof UserWithdrawalRequestReason)[keyof typeof UserWithdrawalRequestReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserWithdrawalRequestReason = {
  NOT_USING: "NOT_USING",
  INCONVENIENT: "INCONVENIENT",
  LACKS_CONTENT: "LACKS_CONTENT",
  BAD_EXPERIENCE: "BAD_EXPERIENCE",
  COST_BURDEN: "COST_BURDEN",
  OTHER: "OTHER",
} as const;

/**
 * íšŒì› íƒˆí‡´ ìš”ì²­
 */
export interface UserWithdrawalRequest {
  /** íƒˆí‡´ ì‚¬ìœ  */
  reason: UserWithdrawalRequestReason;
  /** ì¶”ê°€ ì˜ê²¬ (ì„ íƒì‚¬í•­) */
  additionalComment?: string;
}

/**
 * ì´ë©”ì¼ ì¸ì¦ ì½”ë“œ ê²€ì¦ ìš”ì²­
 */
export interface VerifyEmailCodeRequest {
  /** ì‚¬ìš©ì ì´ë©”ì¼ */
  email: string;
  /**
   * ì´ë©”ì¼ë¡œ ë°œì†¡ëœ ì¸ì¦ ì½”ë“œ
   * @minLength 4
   * @maxLength 4
   */
  verificationCode: string;
}

export interface NicknameRequest {
  /**
   * ë‹‰ë„¤ì„
   * @pattern ^[ê°€-í£a-zA-Z0-9]{2,15}$
   */
  nickname: string;
}

/**
 * ì•½ê´€ ë™ì˜ ìœ í˜•
 */
export type SignUpRequestTermsTypesItem =
  (typeof SignUpRequestTermsTypesItem)[keyof typeof SignUpRequestTermsTypesItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SignUpRequestTermsTypesItem = {
  AGE_POLICY: "AGE_POLICY",
  PRIVACY_POLICY: "PRIVACY_POLICY",
  SERVICE_TERMS_POLICY: "SERVICE_TERMS_POLICY",
  SELLER_TERMS_POLICY: "SELLER_TERMS_POLICY",
  MARKETING_POLICY: "MARKETING_POLICY",
} as const;

/**
 * íšŒì›ê°€ì… ì •ë³´
 */
export interface SignUpRequest {
  /**
   * ì‚¬ìš©ì ìœ í˜•
   * @pattern ^(SELLER|BUYER)$
   */
  userType: string;
  /** ì•½ê´€ ë™ì˜ ìœ í˜• */
  termsTypes: SignUpRequestTermsTypesItem[];
  /** ì¸ì¦ëœ ì´ë©”ì¼ */
  email: string;
  /**
   * ë¹„ë°€ë²ˆí˜¸
   * @minLength 8
   * @maxLength 32
   * @pattern ^(?=.*[0-9])(?=.*[a-zA-Z])(?=.*[!@#$%^&*]).{8,}$
   */
  password: string;
  /**
   * ë‹‰ë„¤ì„
   * @pattern ^[ê°€-í£a-zA-Z0-9]{2,15}$
   */
  nickname: string;
  /**
   * ì „í™”ë²ˆí˜¸
   * @pattern ^\d{3}-\d{3,4}-\d{4}$
   */
  phoneNumber?: string;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type SignUpApiResponseStatus =
  (typeof SignUpApiResponseStatus)[keyof typeof SignUpApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SignUpApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

export interface SignUpApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: SignUpApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  data?: SignUpResponse;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ)
 */
export interface SignUpResponse {
  /** íšŒì›ê°€ì…ì„ ì§„í–‰í•œ ì´ë©”ì¼ */
  email?: string;
  /** íšŒì›ê°€ì… ì„±ê³µ ì—¬ë¶€ */
  authenticated?: boolean;
}

/**
 * ì•½ê´€ ë™ì˜ ìœ í˜•
 */
export type SocialSignUpRequestTermsTypesItem =
  (typeof SocialSignUpRequestTermsTypesItem)[keyof typeof SocialSignUpRequestTermsTypesItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SocialSignUpRequestTermsTypesItem = {
  AGE_POLICY: "AGE_POLICY",
  PRIVACY_POLICY: "PRIVACY_POLICY",
  SERVICE_TERMS_POLICY: "SERVICE_TERMS_POLICY",
  SELLER_TERMS_POLICY: "SELLER_TERMS_POLICY",
  MARKETING_POLICY: "MARKETING_POLICY",
} as const;

/**
 * íšŒì›ê°€ì… ì •ë³´
 */
export interface SocialSignUpRequest {
  /**
   * ì‚¬ìš©ì ìœ í˜•
   * @pattern ^(SELLER|BUYER)$
   */
  userType: string;
  /** ì•½ê´€ ë™ì˜ ìœ í˜• */
  termsTypes: SocialSignUpRequestTermsTypesItem[];
  /**
   * ë‹‰ë„¤ì„
   * @pattern ^[ê°€-í£a-zA-Z0-9]{2,15}$
   */
  nickname: string;
  /**
   * ì „í™”ë²ˆí˜¸
   * @pattern ^\d{3}-\d{3,4}-\d{4}$
   */
  phoneNumber?: string;
}

/**
 * ë¡œê·¸ì¸ ì •ë³´
 */
export interface SignInRequest {
  /** ì‚¬ìš©ì ì´ë©”ì¼ */
  email: string;
  /**
   * ì‚¬ìš©ì ë¹„ë°€ë²ˆí˜¸
   * @minLength 6
   * @maxLength 32
   * @pattern ^(?=.*[0-9])(?=.*[a-zA-Z])(?=.*[!@#$%^&*]).{6,}$
   */
  password: string;
}

/**
 * ì „í™”ë²ˆí˜¸ ì¸ì¦ ì •ë³´
 */
export interface PhoneNumberVerifyRequest {
  /**
   * ì „í™”ë²ˆí˜¸
   * @pattern ^\d{3}-\d{3,4}-\d{4}$
   */
  phoneNumber: string;
}

/**
 * ì „í™”ë²ˆí˜¸ ì¸ì¦ ì •ë³´
 */
export interface PhoneNumberVerifyCodeRequest {
  /**
   * ì „í™”ë²ˆí˜¸
   * @pattern ^\d{3}-\d{3,4}-\d{4}$
   */
  phoneNumber: string;
  /**
   * ì¸ì¦ë²ˆí˜¸
   * @pattern ^\d{4}$
   */
  verificationCode: string;
}

export interface ResetPasswordRequest {
  /**
   * @minLength 8
   * @maxLength 32
   * @pattern ^(?=.*[0-9])(?=.*[a-zA-Z])(?=.*[!@#$%^&*]).{8,}$
   */
  newPassword: string;
  token: string;
}

/**
 * ì´ë©”ì¼ ì¸ì¦ ì •ë³´
 */
export interface EmailVerificationRequest {
  email: string;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type UserMyPageSummaryApiResponseStatus =
  (typeof UserMyPageSummaryApiResponseStatus)[keyof typeof UserMyPageSummaryApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserMyPageSummaryApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

export interface UserMyPageSummaryApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: UserMyPageSummaryApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  data?: UserMyPageSummaryResponse;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ë§ˆì´í˜ì´ì§€ ìš”ì•½ ì •ë³´ ì‘ë‹µ
 */
export interface UserMyPageSummaryResponse {
  /** ì‚¬ìš©ì ë‹‰ë„¤ì„ */
  nickname?: string;
  /** í”„ë¡œí•„ ì´ë¯¸ì§€ URL */
  profileImageUrl?: string;
  /** ì‚¬ìš©ì ìœ í˜• (BUYER/SELLER) */
  userType?: string;
  /** íŒë§¤ì ì „í™˜ ê°€ëŠ¥ ì—¬ë¶€ */
  canSwitchToSeller?: boolean;
  /** íŒë§¤ì ì¸ì¦ ìƒíƒœ */
  verificationStatus?: string;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type UserMyPageDetailApiResponseStatus =
  (typeof UserMyPageDetailApiResponseStatus)[keyof typeof UserMyPageDetailApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserMyPageDetailApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

export interface UserMyPageDetailApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: UserMyPageDetailApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  data?: UserMyPageDetailResponse;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ)
 */
export interface UserMyPageDetailResponse {
  /** ì‚¬ìš©ì ë‹‰ë„¤ì„ */
  nickname?: string;
  /** ì‚¬ìš©ì ë§ˆì§€ë§‰ ì„ íƒ ìœ í˜• */
  userType?: string;
  /** ì‚¬ìš©ì ê³„ì • ìœ í˜• (INTEGRATED: í†µí•© ê³„ì •, SOCIAL: ì†Œì…œ ê³„ì •) */
  accountType?: string;
  /** ì†Œì…œ í”Œë«í¼ ìœ í˜• (ê°€ëŠ¥í•œ ê°’: KAKAO - ì¹´ì¹´ì˜¤, NAVER - ë„¤ì´ë²„, GOOGLE - êµ¬ê¸€) */
  providerType?: string;
  /** ì´ë©”ì¼ */
  email?: string;
  /** í”„ë¡œí•„ ì´ë¯¸ì§€ URL */
  profileImageUrl?: string;
  /** ì „í™”ë²ˆí˜¸ */
  phoneNumber?: string;
  /** íŒë§¤ì ê³„ì • ì „í™˜ ê°€ëŠ¥ ì—¬ë¶€ (í˜„ì¬ userType : BUYER ê²½ìš°ì— TRUE / í˜„ì¬ userType : SELLER ê²½ìš°ì— FALSE) */
  canSwitchToSeller?: boolean;
  /** íŒë§¤ì ê³„ì • ë¯¸ìƒì„± ì—¬ë¶€ */
  sellerAccountNotCreated?: boolean;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type ContentExamineRejectApiResponseStatus =
  (typeof ContentExamineRejectApiResponseStatus)[keyof typeof ContentExamineRejectApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ContentExamineRejectApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

export interface ContentExamineRejectApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: ContentExamineRejectApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  /** ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ) */
  data?: string;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì»¤ì„œ ê¸°ë°˜ í˜ì´ì§€ë„¤ì´ì…˜ ìš”ì²­
 */
export interface CursorRequest {
  /** ë‹¤ìŒ í˜ì´ì§€ ìš”ì²­ì— ì‚¬ìš©í•  ì»¤ì„œ (ì²« í˜ì´ì§€ëŠ” null ë˜ëŠ” ë¹ˆ ë¬¸ìì—´) */
  cursor?: string;
  /**
   * ìš”ì²­ í˜ì´ì§€ í¬ê¸° (ìµœì†Œ 1)
   * @minimum 1
   */
  size: number;
  /** ì •ë ¬ ê¸°ì¤€ í•„ë“œëª… */
  sortBy?: string;
  /** ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ ì—¬ë¶€ (true: ë‚´ë¦¼ì°¨ìˆœ, false: ì˜¤ë¦„ì°¨ìˆœ) */
  sortDesc?: boolean;
  first?: boolean;
}

/**
 * ì½˜í…ì¸  ìƒíƒœ [ACTIVE - íŒë§¤ì¤‘], [DRAFT - ì‘ì„±ì¤‘], [PENDING - ì‹¬ì‚¬ì¤‘], [VALIDATED - ì‹¬ì‚¬ì™„ë£Œ(ìŠ¹ì¸)], [REJECTED - ì‹¬ì‚¬ì™„ë£Œ(ê±°ì ˆ)]
 */
export type ContentPreviewCardResponseStatus =
  (typeof ContentPreviewCardResponseStatus)[keyof typeof ContentPreviewCardResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ContentPreviewCardResponseStatus = {
  ACTIVE: "ACTIVE",
  DRAFT: "DRAFT",
  PENDING: "PENDING",
  VALIDATED: "VALIDATED",
  REJECTED: "REJECTED",
} as const;

/**
 * ì½˜í…ì¸  ë¯¸ë¦¬ë³´ê¸° ì¹´ë“œ ì‘ë‹µ DTO
 */
export interface ContentPreviewCardResponse {
  /** ì½˜í…ì¸  ID */
  contentId?: number;
  /** ìƒì„± ì¼ì‹œ */
  createdAt?: string;
  /** ì½˜í…ì¸  ì œëª© */
  title?: string;
  /** ì¸ë„¤ì¼ ì´ë¯¸ì§€ URL */
  thumbnailUrl?: string;
  /** íŒë§¤ì ì´ë¦„ */
  sellerName?: string;
  /** ì½˜í…ì¸  ìµœì €ê°€ ê°€ê²© (nullì¸ ê²½ìš° -> ê°€ê²©ë¯¸ì •) */
  lowestPrice?: number;
  /** ê°€ê²© ì˜µì…˜ ê°œìˆ˜ */
  priceOptionLength?: number;
  /** ì½˜í…ì¸  ìƒíƒœ [ACTIVE - íŒë§¤ì¤‘], [DRAFT - ì‘ì„±ì¤‘], [PENDING - ì‹¬ì‚¬ì¤‘], [VALIDATED - ì‹¬ì‚¬ì™„ë£Œ(ìŠ¹ì¸)], [REJECTED - ì‹¬ì‚¬ì™„ë£Œ(ê±°ì ˆ)] */
  status?: ContentPreviewCardResponseStatus;
}

/**
 * ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ)
 */
export interface CursorResponseContentPreviewCardResponse {
  items?: ContentPreviewCardResponse[];
  nextCursor?: string;
  hasNext?: boolean;
  totalCount?: number;
  meta?: MetaData;
}

export interface MetaData {
  searchTerm?: string;
  filter?: string;
  sortBy?: string;
  sortDirection?: string;
  categoryIds?: string[];
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type MySellingContentsApiResponseStatus =
  (typeof MySellingContentsApiResponseStatus)[keyof typeof MySellingContentsApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MySellingContentsApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

export interface MySellingContentsApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: MySellingContentsApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  data?: CursorResponseContentPreviewCardResponse;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type ContentScrapCardApiResponseStatus =
  (typeof ContentScrapCardApiResponseStatus)[keyof typeof ContentScrapCardApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ContentScrapCardApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

/**
 * ìŠ¤í¬ë©í•œ ì½˜í…ì¸  ëª©ë¡ ì¡°íšŒ ì‘ë‹µ
 */
export interface ContentScrapCardApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: ContentScrapCardApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  data?: CursorResponseContentScrapCardResponse;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì½˜í…ì¸  ìŠ¤í¬ë©ìš© ì¹´ë“œ ì‘ë‹µ DTO
 */
export interface ContentScrapCardResponse {
  /** ì½˜í…ì¸  ID */
  contentId?: number;
  /** ì½˜í…ì¸  ìœ í˜• [COACHING - ì„œë¹„ìŠ¤], [DOCUMENT - ìë£Œ] */
  contentType?: string;
  /** ì½˜í…ì¸  ì œëª© */
  title?: string;
  /** ì¸ë„¤ì¼ ì´ë¯¸ì§€ URL */
  thumbnailUrl?: string;
  /** íŒë§¤ì ì´ë¦„ */
  sellerName?: string;
  /** ì½˜í…ì¸  ìŠ¤í¬ë© ì—¬ë¶€ */
  isContentScrap?: boolean;
}

/**
 * ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ)
 */
export interface CursorResponseContentScrapCardResponse {
  items?: ContentScrapCardResponse[];
  nextCursor?: string;
  hasNext?: boolean;
  totalCount?: number;
  meta?: MetaData;
}

/**
 * ì•Œë¦¼ ìƒì„¸ ì‘ë‹µ
 */
export interface NotificationDetails {
  /** ë‹‰ë„¤ì„ */
  nickname?: string;
  /** ì½˜í…ì¸  ID (CONTENT íƒ€ì…ì—ì„œ ì‚¬ìš©) */
  contentId?: number;
  /** ì¸ë„¤ì¼ URL (CONTENT íƒ€ì…ì—ì„œ ì‚¬ìš©) */
  thumbnailUrl?: string;
  /** ì‹œìŠ¤í…œ ì•Œë¦¼ ì œëª© (SYSTEM íƒ€ì…ì—ì„œ ì‚¬ìš©) */
  systemTitle?: string;
}

/**
 * ì•Œë¦¼ íƒ€ì…
 */
export type NotificationItemNotificationType =
  (typeof NotificationItemNotificationType)[keyof typeof NotificationItemNotificationType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationItemNotificationType = {
  SELLER: "SELLER",
  CONTENT: "CONTENT",
  SYSTEM: "SYSTEM",
} as const;

/**
 * ì•Œë¦¼ ì„œë¸Œ íƒ€ì…
 */
export type NotificationItemSubNotificationType =
  (typeof NotificationItemSubNotificationType)[keyof typeof NotificationItemSubNotificationType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationItemSubNotificationType = {
  SELLER_VERIFIED: "SELLER_VERIFIED",
  SELLER_REJECTED: "SELLER_REJECTED",
  CONTENT_APPROVED: "CONTENT_APPROVED",
  CONTENT_REJECTED: "CONTENT_REJECTED",
  WELCOME_GROBLE: "WELCOME_GROBLE",
} as const;

/**
 * ì•Œë¦¼ ì½ìŒ ìƒíƒœ
 */
export type NotificationItemNotificationReadStatus =
  (typeof NotificationItemNotificationReadStatus)[keyof typeof NotificationItemNotificationReadStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationItemNotificationReadStatus = {
  READ: "READ",
  UNREAD: "UNREAD",
} as const;

/**
 * ì•Œë¦¼ ì•„ì´í…œ
 */
export interface NotificationItem {
  /** ì•Œë¦¼ ID */
  notificationId?: number;
  /** ì•Œë¦¼ íƒ€ì… */
  notificationType?: NotificationItemNotificationType;
  /** ì•Œë¦¼ ì„œë¸Œ íƒ€ì… */
  subNotificationType?: NotificationItemSubNotificationType;
  /** ì•Œë¦¼ ì½ìŒ ìƒíƒœ */
  notificationReadStatus?: NotificationItemNotificationReadStatus;
  /** ì•Œë¦¼ ë°œìƒ ì‹œê°„ (ìƒëŒ€ì  ì‹œê°„ í‘œì‹œ, ì˜ˆ: '3ì¼ ì „') */
  notificationOccurTime?: string;
  notificationDetails?: NotificationDetails;
}

/**
 * ì•Œë¦¼ ëª©ë¡ ì‘ë‹µ
 */
export interface NotificationItems {
  /** ì•Œë¦¼ ëª©ë¡ ë¦¬ìŠ¤íŠ¸ */
  notificationItems?: NotificationItem[];
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type NotificationItemsApiResponseStatus =
  (typeof NotificationItemsApiResponseStatus)[keyof typeof NotificationItemsApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationItemsApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

export interface NotificationItemsApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: NotificationItemsApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  data?: NotificationItems;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type UserHeaderApiResponseStatus =
  (typeof UserHeaderApiResponseStatus)[keyof typeof UserHeaderApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserHeaderApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

export interface UserHeaderApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: UserHeaderApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  data?: UserHeaderResponse;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ)
 */
export interface UserHeaderResponse {
  /** ë¡œê·¸ì¸ ìƒíƒœ ì—¬ë¶€ */
  isLogin?: boolean;
  /** ì‚¬ìš©ì ë‹‰ë„¤ì„ */
  nickname?: string;
  /** í”„ë¡œí•„ ì´ë¯¸ì§€ URL */
  profileImageUrl?: string;
  /** íŒë§¤ì ì „í™˜ ê°€ëŠ¥ ì—¬ë¶€ [í˜„ì¬ BUYERë¼ë©´ true, SELLERë¼ë©´ false] */
  canSwitchToSeller?: boolean;
  /** ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜ */
  unreadNotificationCount?: number;
  /** íŒë§¤ì ë“±ë¡ ì—¬ë¶€ [ì‚¬ìš©ìì˜ SELLER ì†Œìœ  ì—¬ë¶€ íŒë‹¨] */
  alreadyRegisteredAsSeller?: boolean;
  /** ë§ˆì§€ë§‰ìœ¼ë¡œ ì‚¬ìš©í•œ ì‚¬ìš©ì ìœ í˜• */
  lastUserType?: string;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type HomeContentsApiResponseStatus =
  (typeof HomeContentsApiResponseStatus)[keyof typeof HomeContentsApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HomeContentsApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

export interface HomeContentsApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: HomeContentsApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  data?: HomeContentsResponse;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ)
 */
export interface HomeContentsResponse {
  coachingItems?: ContentPreviewCardResponse[];
  documentItems?: ContentPreviewCardResponse[];
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type ContentsCategoryApiResponseStatus =
  (typeof ContentsCategoryApiResponseStatus)[keyof typeof ContentsCategoryApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ContentsCategoryApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

export interface ContentsCategoryApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: ContentsCategoryApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  data?: PageResponseContentPreviewCardResponse;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

export interface PageInfo {
  currentPage?: number;
  totalPages?: number;
  pageSize?: number;
  totalElements?: number;
  first?: boolean;
  last?: boolean;
  empty?: boolean;
}

/**
 * ì‘ë‹µ ë°ì´í„° (ìš”ì²­ ì„±ê³µ ì‹œ)
 */
export interface PageResponseContentPreviewCardResponse {
  items?: ContentPreviewCardResponse[];
  pageInfo?: PageInfo;
  meta?: MetaData;
}

/**
 * ì‘ë‹µ ìƒíƒœ íƒ€ì…
 */
export type ContentDetailApiResponseStatus =
  (typeof ContentDetailApiResponseStatus)[keyof typeof ContentDetailApiResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ContentDetailApiResponseStatus = {
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  FAIL: "FAIL",
} as const;

export interface ContentDetailApiResponse {
  /** ì‘ë‹µ ìƒíƒœ íƒ€ì… */
  status?: ContentDetailApiResponseStatus;
  /** HTTP ìƒíƒœ ì½”ë“œ ë˜ëŠ” ì»¤ìŠ¤í…€ ì½”ë“œ */
  code?: number;
  /** ì‘ë‹µ ë©”ì‹œì§€ */
  message?: string;
  data?: ContentDetailResponse;
  error?: ErrorDetail;
  /** ì‘ë‹µ ìƒì„± ì‹œê°„ */
  timestamp?: string;
}

/**
 * ì½˜í…ì¸  ìƒíƒœ [ACTIVE - íŒë§¤ì¤‘], [DRAFT - ì‘ì„±ì¤‘], [PENDING - ì‹¬ì‚¬ì¤‘], [VALIDATED - ì‹¬ì‚¬ì™„ë£Œ(ìŠ¹ì¸)], [REJECTED - ì‹¬ì‚¬ì™„ë£Œ(ê±°ì ˆ)]
 */
export type ContentDetailResponseStatus =
  (typeof ContentDetailResponseStatus)[keyof typeof ContentDetailResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ContentDetailResponseStatus = {
  ACTIVE: "ACTIVE",
  DRAFT: "DRAFT",
  PENDING: "PENDING",
  VALIDATED: "VALIDATED",
  REJECTED: "REJECTED",
} as const;

/**
 * ì½˜í…ì¸  ìƒì„¸ ì •ë³´ ì‘ë‹µ
 */
export interface ContentDetailResponse {
  /** ì½˜í…ì¸  ID */
  contentId?: number;
  /** ì½˜í…ì¸  ìƒíƒœ [ACTIVE - íŒë§¤ì¤‘], [DRAFT - ì‘ì„±ì¤‘], [PENDING - ì‹¬ì‚¬ì¤‘], [VALIDATED - ì‹¬ì‚¬ì™„ë£Œ(ìŠ¹ì¸)], [REJECTED - ì‹¬ì‚¬ì™„ë£Œ(ê±°ì ˆ)] */
  status?: ContentDetailResponseStatus;
  /** ì¸ë„¤ì¼ ì´ë¯¸ì§€ URL */
  thumbnailUrl?: string;
  /** ì½˜í…ì¸  ìœ í˜• [COACHING - ì„œë¹„ìŠ¤], [DOCUMENT - ìë£Œ] */
  contentType?: string;
  /** ì¹´í…Œê³ ë¦¬ ID */
  categoryId?: string;
  /** ì½˜í…ì¸  ì´ë¦„ */
  title?: string;
  /** íŒë§¤ì í”„ë¡œí•„ ì´ë¯¸ì§€ URL */
  sellerProfileImageUrl?: string;
  /** íŒë§¤ì ì´ë¦„ */
  sellerName?: string;
  /** ì½˜í…ì¸  ìµœì €ê°€ */
  lowestPrice?: number;
  /** ê°€ê²© ì˜µì…˜ ê°œìˆ˜ */
  priceOptionLength?: number;
  options?: OptionResponseDoc[];
  /** ì½˜í…ì¸  ì†Œê°œ */
  contentIntroduction?: string;
  /** ì„œë¹„ìŠ¤ íƒ€ê²Ÿ */
  serviceTarget?: string;
  /** ì œê³µ ì ˆì°¨ */
  serviceProcess?: string;
  /** ë©”ì´ì»¤ ì†Œê°œ */
  makerIntro?: string;
}

/**
 * ì„œë¹„ìŠ¤/ë¬¸ì„œ ì˜µì…˜ì˜ ëª¨ë“  í•„ë“œë¥¼ í¬í•¨í•œ ì‘ë‹µ ìŠ¤í™ (ë¬¸ì„œìš©)
 */
export interface OptionResponseDoc {
  /** ì˜µì…˜ ID */
  optionId?: number;
  /** ì˜µì…˜ ìœ í˜• */
  optionType?: string;
  /** ì˜µì…˜ ì´ë¦„ */
  name?: string;
  /** ì˜µì…˜ ì„¤ëª… */
  description?: string;
  /** ì˜µì…˜ ê°€ê²© */
  price?: number;

  /** ë¬¸ì„œ íŒŒì¼ URL */
  documentFileUrl?: string;
  /** ë¬¸ì„œ ë§í¬ URL */
  documentLinkUrl?: string;
}

export type SwitchUserTypeParams = {
  accessor: Accessor;
};

export type UploadProfileImageParams = {
  accessor: Accessor;
};

export type UploadProfileImageBody = {
  /** í”„ë¡œí•„ ì´ë¯¸ì§€ íŒŒì¼ */
  profileImage: Blob;
};

export type WithdrawTermsAgreementParams = {
  accessor: Accessor;
};

export type GetAdvertisingAgreementStatusParams = {
  accessor: Accessor;
};

export type UpdateAdvertisingAgreementStatusParams = {
  accessor: Accessor;
};

export type AgreeMakerTermsParams = {
  accessor: Accessor;
};

export type AgreeToTermsParams = {
  accessor: Accessor;
};

export type CreateOrderParams = {
  accessor: Accessor;
};

export type UploadFileParams = {
  accessor: Accessor;
  fileType?: string;
  directory?: string;
};

export type UploadFileBody = {
  file: Blob;
};

export type UploadContentThumbnailParams = {
  accessor: Accessor;
  directory?: string;
};

export type UploadContentThumbnailBody = {
  file: Blob;
};

export type AddContentThumbnailImageParams = {
  accessor: Accessor;
};

export type AddContentThumbnailImageBody = {
  /** ì½˜í…ì¸  ì¸ë„¤ì¼ ì´ë¯¸ì§€ íŒŒì¼ */
  contentThumbnailImage: Blob;
};

export type AddContentDocumentFileParams = {
  accessor: Accessor;
};

export type AddContentDocumentFileBody = {
  /** ì½˜í…ì¸  ìë£Œ íŒŒì¼ */
  contentDocumentFile: Blob;
};

export type UploadContentsFilesParams = {
  accessor: Accessor;
  files: Blob[];
  directory?: string;
};

export type AddContentDetailImagesParams = {
  accessor: Accessor;
};

export type AddContentDetailImagesBody = {
  /** ì½˜í…ì¸  ìƒì„¸ ì´ë¯¸ì§€ íŒŒì¼ë“¤ (ì—¬ëŸ¬ ê°œ ê°€ëŠ¥) */
  contentDetailImages: Blob[];
};

export type WithdrawUserParams = {
  accessor: Accessor;
};

export type VerifyEmailCodeForChangeEmailParams = {
  accessor: Accessor;
};

export type ValidateTokenParams = {
  accessor: Accessor;
};

export type UpdateNicknameParams = {
  accessor: Accessor;
};

export type SignUpSocialParams = {
  accessor: Accessor;
};

export type AuthPhoneNumberParams = {
  accessor: Accessor;
};

export type VerifyPhoneNumberParams = {
  accessor: Accessor;
};

export type LogoutParams = {
  accessor: Accessor;
};

export type SetInitialUserTypeParams = {
  accessor: Accessor;
};

export type SendEmailVerificationForChangeEmailParams = {
  accessor: Accessor;
};

export type GetUserMyPageSummaryParams = {
  accessor: Accessor;
};

export type GetUserMyPageDetailParams = {
  accessor: Accessor;
};

export type GetUserTermsAgreementsParams = {
  accessor: Accessor;
};

export type GetExamineRejectReasonParams = {
  accessor: Accessor;
};

export type GetMySellingContentsParams = {
  /**
   * ì»¤ì„œ ê¸°ë°˜ í˜ì´ì§€ë„¤ì´ì…˜ ìš”ì²­ ì •ë³´
   */
  cursorRequest: CursorRequest;
  /**
   * ì½˜í…ì¸  ìƒíƒœ í•„í„° [ACTIVE - íŒë§¤ì¤‘], [DRAFT - ì‘ì„±ì¤‘], [PENDING - ì‹¬ì‚¬ì¤‘], [APPROVED - ì‹¬ì‚¬ì™„ë£Œ]
   */
  state: string;
  /**
   * ì½˜í…ì¸  ìœ í˜• [COACHING - ì½”ì°½], [DOCUMENT - ìë£Œ]
   */
  type: string;
};

export type GetMyScrapContentsParams = {
  /**
   * ì»¤ì„œ ê¸°ë°˜ í˜ì´ì§€ë„¤ì´ì…˜ ìš”ì²­ ì •ë³´
   */
  cursorRequest: CursorRequest;
  /**
   * ì½˜í…ì¸  íƒ€ì… (COACHING ë˜ëŠ” DOCUMENT)
   */
  type: string;
  /**
   * ë§ˆì§€ë§‰ìœ¼ë¡œ ì¡°íšŒí•œ ì½˜í…ì¸  ID (ì²« í˜ì´ì§€ëŠ” null)
   */
  lastContentId?: number;
  /**
   * í˜ì´ì§€ í¬ê¸°
   */
  size?: number;
  /**
   * ì½˜í…ì¸  ìœ í˜• [COACHING - ì„œë¹„ìŠ¤, DOCUMENT - ìë£Œ]
   */
  contentType?: GetMyScrapContentsContentType;
};

export type GetMyScrapContentsContentType =
  (typeof GetMyScrapContentsContentType)[keyof typeof GetMyScrapContentsContentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMyScrapContentsContentType = {
  COACHING: "COACHING",
  DOCUMENT: "DOCUMENT",
} as const;

export type GetMyPurchasingContentsParams = {
  /**
   * ì»¤ì„œ ê¸°ë°˜ í˜ì´ì§€ë„¤ì´ì…˜ ìš”ì²­ ì •ë³´
   */
  cursorRequest: CursorRequest;
  /**
   * êµ¬ë§¤í•œ ì½˜í…ì¸  ìƒíƒœ í•„í„° (PENDING, PAID, EXPIRED, CANCELLED)
   */
  state?: string;
  /**
   * ì½˜í…ì¸  íƒ€ì… (COACHING ë˜ëŠ” DOCUMENT)
   */
  type: string;
};

export type AuthorizeParams = {
  redirect_uri?: string;
  provider: string;
};

export type GetUserHeaderInformParams = {
  accessor: Accessor;
};

export type GetDocumentContentsByCategoryParams = {
  /**
   * ì¹´í…Œê³ ë¦¬ ì½”ë“œ (ì—¬ëŸ¬ ê°œ ì „ë‹¬ ê°€ëŠ¥)
   */
  categoryId?: string[];
  page?: number;
  size?: number;
  sort?: string;
};

export type GetCoachingContentsByCategoryParams = {
  /**
   * ì¹´í…Œê³ ë¦¬ ì½”ë“œ (ì—¬ëŸ¬ ê°œ ì „ë‹¬ ê°€ëŠ¥)
   */
  categoryId?: string[];
  page?: number;
  size?: number;
  sort?: string;
};

export type GetContentDetailParams = {
  accessor: Accessor;
};

export type CheckNicknameDuplicateParams = {
  nickname: string;
};

/**
 * íŒë§¤ì ë˜ëŠ” êµ¬ë§¤ìë¡œ ê°€ì… ìœ í˜•ì„ ì „í™˜í•©ë‹ˆë‹¤.
 * @summary ê°€ì… ìœ í˜• ì „í™˜
 */
export type switchUserTypeResponse204 = {
  data: UserSwitchRoleApiResponse;
  status: 204;
};

export type switchUserTypeResponse400 = {
  data: UserSwitchRoleApiResponse;
  status: 400;
};

export type switchUserTypeResponse401 = {
  data: GrobleResponse;
  status: 401;
};

export type switchUserTypeResponseComposite =
  | switchUserTypeResponse204
  | switchUserTypeResponse400
  | switchUserTypeResponse401;

export type switchUserTypeResponse = switchUserTypeResponseComposite & {
  headers: Headers;
};

export const getSwitchUserTypeUrl = (params: SwitchUserTypeParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/users/switch-role?${stringifiedParams}`
    : `/api/v1/users/switch-role`;
};

export const switchUserType = async (
  userTypeRequest: UserTypeRequest,
  params: SwitchUserTypeParams,
  options?: RequestInit
): Promise<switchUserTypeResponse> => {
  return customFetch<switchUserTypeResponse>(getSwitchUserTypeUrl(params), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(userTypeRequest),
  });
};

/**
 * ì‚¬ìš©ì í”„ë¡œí•„ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•©ë‹ˆë‹¤. ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•˜ë©°, ë‹¤ë¥¸ íŒŒì¼ í˜•ì‹ì€ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤.
 * @summary ì‚¬ìš©ì í”„ë¡œí•„ ì´ë¯¸ì§€ ì—…ë¡œë“œ
 */
export type uploadProfileImageResponse201 = {
  data: FileUploadApiResponse;
  status: 201;
};

export type uploadProfileImageResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type uploadProfileImageResponseComposite =
  | uploadProfileImageResponse201
  | uploadProfileImageResponse400;

export type uploadProfileImageResponse = uploadProfileImageResponseComposite & {
  headers: Headers;
};

export const getUploadProfileImageUrl = (params: UploadProfileImageParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/me/profile-image?${stringifiedParams}`
    : `/api/v1/me/profile-image`;
};

export const uploadProfileImage = async (
  uploadProfileImageBody: UploadProfileImageBody,
  params: UploadProfileImageParams,
  options?: RequestInit
): Promise<uploadProfileImageResponse> => {
  const formData = new FormData();
  formData.append(`profileImage`, uploadProfileImageBody.profileImage);

  return customFetch<uploadProfileImageResponse>(
    getUploadProfileImageUrl(params),
    {
      ...options,
      method: "POST",
      body: formData,
    }
  );
};

/**
 * ì‚¬ìš©ìê°€ ë™ì˜í•œ ì•½ê´€ì„ ì² íšŒí•©ë‹ˆë‹¤. í•„ìˆ˜ ì•½ê´€ì€ ì² íšŒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
 * @summary ì•½ê´€ ë™ì˜ ì² íšŒ
 */
export type withdrawTermsAgreementResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type withdrawTermsAgreementResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type withdrawTermsAgreementResponseComposite =
  | withdrawTermsAgreementResponse200
  | withdrawTermsAgreementResponse400;

export type withdrawTermsAgreementResponse =
  withdrawTermsAgreementResponseComposite & {
    headers: Headers;
  };

export const getWithdrawTermsAgreementUrl = (
  params: WithdrawTermsAgreementParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/terms/withdraw?${stringifiedParams}`
    : `/api/v1/terms/withdraw`;
};

export const withdrawTermsAgreement = async (
  termsAgreementRequest: TermsAgreementRequest,
  params: WithdrawTermsAgreementParams,
  options?: RequestInit
): Promise<withdrawTermsAgreementResponse> => {
  return customFetch<withdrawTermsAgreementResponse>(
    getWithdrawTermsAgreementUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(termsAgreementRequest),
    }
  );
};

/**
 * í˜„ì¬ ë¡œê·¸ì¸í•œ ì‚¬ìš©ìì˜ ê´‘ê³ ì„± ì •ë³´ ìˆ˜ì‹  ë™ì˜ ì—¬ë¶€ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ê´‘ê³ ì„± ì •ë³´ ìˆ˜ì‹  ë™ì˜ ì—¬ë¶€ ì¡°íšŒ
 */
export type getAdvertisingAgreementStatusResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type getAdvertisingAgreementStatusResponseComposite =
  getAdvertisingAgreementStatusResponse200;

export type getAdvertisingAgreementStatusResponse =
  getAdvertisingAgreementStatusResponseComposite & {
    headers: Headers;
  };

export const getGetAdvertisingAgreementStatusUrl = (
  params: GetAdvertisingAgreementStatusParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/terms/users/me/advertising-agreement?${stringifiedParams}`
    : `/api/v1/terms/users/me/advertising-agreement`;
};

export const getAdvertisingAgreementStatus = async (
  params: GetAdvertisingAgreementStatusParams,
  options?: RequestInit
): Promise<getAdvertisingAgreementStatusResponse> => {
  return customFetch<getAdvertisingAgreementStatusResponse>(
    getGetAdvertisingAgreementStatusUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

/**
 * í˜„ì¬ ë¡œê·¸ì¸í•œ ì‚¬ìš©ìì˜ ê´‘ê³ ì„± ì •ë³´ ìˆ˜ì‹  ë™ì˜ ì—¬ë¶€ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
 * @summary ê´‘ê³ ì„± ì •ë³´ ìˆ˜ì‹  ë™ì˜ ë³€ê²½
 */
export type updateAdvertisingAgreementStatusResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type updateAdvertisingAgreementStatusResponseComposite =
  updateAdvertisingAgreementStatusResponse200;

export type updateAdvertisingAgreementStatusResponse =
  updateAdvertisingAgreementStatusResponseComposite & {
    headers: Headers;
  };

export const getUpdateAdvertisingAgreementStatusUrl = (
  params: UpdateAdvertisingAgreementStatusParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/terms/users/me/advertising-agreement?${stringifiedParams}`
    : `/api/v1/terms/users/me/advertising-agreement`;
};

export const updateAdvertisingAgreementStatus = async (
  advertisingAgreementRequest: AdvertisingAgreementRequest,
  params: UpdateAdvertisingAgreementStatusParams,
  options?: RequestInit
): Promise<updateAdvertisingAgreementStatusResponse> => {
  return customFetch<updateAdvertisingAgreementStatusResponse>(
    getUpdateAdvertisingAgreementStatusUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(advertisingAgreementRequest),
    }
  );
};

/**
 * ë©”ì´ì»¤(íŒë§¤ì)ë¡œ í™œë™í•˜ê¸° ìœ„í•œ ì´ìš©ì•½ê´€ì— ë™ì˜í•©ë‹ˆë‹¤.
 * @summary ë©”ì´ì»¤ ì´ìš©ì•½ê´€ ë™ì˜
 */
export type agreeMakerTermsResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type agreeMakerTermsResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type agreeMakerTermsResponseComposite =
  | agreeMakerTermsResponse200
  | agreeMakerTermsResponse400;

export type agreeMakerTermsResponse = agreeMakerTermsResponseComposite & {
  headers: Headers;
};

export const getAgreeMakerTermsUrl = (params: AgreeMakerTermsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/terms/maker/agree?${stringifiedParams}`
    : `/api/v1/terms/maker/agree`;
};

export const agreeMakerTerms = async (
  makerTermsAgreementRequest: MakerTermsAgreementRequest,
  params: AgreeMakerTermsParams,
  options?: RequestInit
): Promise<agreeMakerTermsResponse> => {
  return customFetch<agreeMakerTermsResponse>(getAgreeMakerTermsUrl(params), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(makerTermsAgreementRequest),
  });
};

/**
 * ì‚¬ìš©ìê°€ íšŒì›ê°€ì… ê³¼ì •ì—ì„œ ì•½ê´€ì— ë™ì˜í•©ë‹ˆë‹¤.
 * @summary íšŒì›ê°€ì… ì•½ê´€ ë™ì˜
 */
export type agreeToTermsResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type agreeToTermsResponseComposite = agreeToTermsResponse200;

export type agreeToTermsResponse = agreeToTermsResponseComposite & {
  headers: Headers;
};

export const getAgreeToTermsUrl = (params: AgreeToTermsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/terms/agree?${stringifiedParams}`
    : `/api/v1/terms/agree`;
};

export const agreeToTerms = async (
  termsAgreementRequest: TermsAgreementRequest,
  params: AgreeToTermsParams,
  options?: RequestInit
): Promise<agreeToTermsResponse> => {
  return customFetch<agreeToTermsResponse>(getAgreeToTermsUrl(params), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(termsAgreementRequest),
  });
};

/**
 * íŒë§¤ ì¤‘ì¸ ì½˜í…ì¸ ë¥¼ íŒë§¤ ì¤‘ë‹¨í•©ë‹ˆë‹¤.
 * @summary ì½˜í…ì¸  íŒë§¤ ì¤‘ë‹¨
 */
export type stopContentResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type stopContentResponseComposite = stopContentResponse200;

export type stopContentResponse = stopContentResponseComposite & {
  headers: Headers;
};

export const getStopContentUrl = (contentId: number) => {
  return `/api/v1/sell/content/${contentId}/stop`;
};

export const stopContent = async (
  contentId: number,
  options?: RequestInit
): Promise<stopContentResponse> => {
  return customFetch<stopContentResponse>(getStopContentUrl(contentId), {
    ...options,
    method: "POST",
  });
};

/**
 * ì‘ì„± ì¤‘ì¸ ì½˜í…ì¸ ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤. íŒë§¤ ì¤‘ë‹¨ëœ ì½˜í…ì¸ ëŠ” ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
 * @summary ì½˜í…ì¸  ì‚­ì œ
 */
export type deleteContentResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type deleteContentResponseComposite = deleteContentResponse200;

export type deleteContentResponse = deleteContentResponseComposite & {
  headers: Headers;
};

export const getDeleteContentUrl = (contentId: number) => {
  return `/api/v1/sell/content/${contentId}/delete`;
};

export const deleteContent = async (
  contentId: number,
  options?: RequestInit
): Promise<deleteContentResponse> => {
  return customFetch<deleteContentResponse>(getDeleteContentUrl(contentId), {
    ...options,
    method: "POST",
  });
};

/**
 * ì‹¬ì‚¬ ì™„ë£Œ ì½˜í…ì¸  ì¤‘ ìŠ¹ì¸ì´ ì™„ë£Œëœ ì½˜í…ì¸ ë¥¼ í™œì„±í™”í•©ë‹ˆë‹¤.
 * @summary ì½˜í…ì¸  í™œì„±í™”
 */
export type activateContentResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type activateContentResponseComposite = activateContentResponse200;

export type activateContentResponse = activateContentResponseComposite & {
  headers: Headers;
};

export const getActivateContentUrl = (contentId: number) => {
  return `/api/v1/sell/content/${contentId}/active`;
};

export const activateContent = async (
  contentId: number,
  options?: RequestInit
): Promise<activateContentResponse> => {
  return customFetch<activateContentResponse>(
    getActivateContentUrl(contentId),
    {
      ...options,
      method: "POST",
    }
  );
};

/**
 * ì½˜í…ì¸  ì‹¬ì‚¬ë¥¼ ìš”ì²­í•©ë‹ˆë‹¤. ì½˜í…ì¸  ìœ í˜•(ì„œë¹„ìŠ¤/ë¬¸ì„œ)ì— ë”°ë¼ ì˜µì…˜ êµ¬ì¡°ê°€ ë‹¬ë¼ì§‘ë‹ˆë‹¤.
 * @summary ì½˜í…ì¸  ì‹¬ì‚¬ ìš”ì²­
 */
export type registerContentResponse200 = {
  data: ContentRegisterApiResponse;
  status: 200;
};

export type registerContentResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type registerContentResponseComposite =
  | registerContentResponse200
  | registerContentResponse400;

export type registerContentResponse = registerContentResponseComposite & {
  headers: Headers;
};

export const getRegisterContentUrl = () => {
  return `/api/v1/sell/content/register`;
};

export const registerContent = async (
  contentRegisterRequest: ContentRegisterRequest,
  options?: RequestInit
): Promise<registerContentResponse> => {
  return customFetch<registerContentResponse>(getRegisterContentUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(contentRegisterRequest),
  });
};

/**
 * ì½˜í…ì¸ ë¥¼ ì„ì‹œ ì €ì¥í•©ë‹ˆë‹¤. ì½˜í…ì¸  ìœ í˜•(ì„œë¹„ìŠ¤/ë¬¸ì„œ)ì— ë”°ë¼ ì˜µì…˜ êµ¬ì¡°ê°€ ë‹¬ë¼ì§‘ë‹ˆë‹¤.
 * @summary ì½˜í…ì¸  ì„ì‹œ ì €ì¥
 */
export type saveDraftResponse200 = {
  data: ContentDraftApiResponse;
  status: 200;
};

export type saveDraftResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type saveDraftResponseComposite =
  | saveDraftResponse200
  | saveDraftResponse400;

export type saveDraftResponse = saveDraftResponseComposite & {
  headers: Headers;
};

export const getSaveDraftUrl = () => {
  return `/api/v1/sell/content/draft`;
};

export const saveDraft = async (
  contentDraftRequest: ContentDraftRequest,
  options?: RequestInit
): Promise<saveDraftResponse> => {
  return customFetch<saveDraftResponse>(getSaveDraftUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(contentDraftRequest),
  });
};

/**
 * ì½˜í…ì¸  ìŠ¤í¬ë© ìƒíƒœ ë³€ê²½ì„ ì§„í–‰í•©ë‹ˆë‹¤. ìŠ¤í¬ë© ì½˜í…ì¸ ëŠ” ë‚˜ì˜ ìŠ¤í¬ë© ëª©ë¡ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * @summary ì½˜í…ì¸  ìŠ¤í¬ë© ìƒíƒœ ë³€ê²½
 */
export type scrapContentResponse200 = {
  data: UpdateContentScrapStateApiResponse;
  status: 200;
};

export type scrapContentResponse401 = {
  data: GrobleResponse;
  status: 401;
};

export type scrapContentResponseComposite =
  | scrapContentResponse200
  | scrapContentResponse401;

export type scrapContentResponse = scrapContentResponseComposite & {
  headers: Headers;
};

export const getScrapContentUrl = (contentId: number) => {
  return `/api/v1/scrap/content/${contentId}`;
};

export const scrapContent = async (
  contentId: number,
  updateContentScrapStateRequest: UpdateContentScrapStateRequest,
  options?: RequestInit
): Promise<scrapContentResponse> => {
  return customFetch<scrapContentResponse>(getScrapContentUrl(contentId), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(updateContentScrapStateRequest),
  });
};

/**
 * ì½˜í…ì¸  êµ¬ë§¤ë¥¼ ìœ„í•œ ì£¼ë¬¸ì„ ìƒì„±í•©ë‹ˆë‹¤. ì¿ í° ì ìš© ê°€ëŠ¥
 * @summary ì£¼ë¬¸ ìƒì„±
 */
export type createOrderResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type createOrderResponseComposite = createOrderResponse200;

export type createOrderResponse = createOrderResponseComposite & {
  headers: Headers;
};

export const getCreateOrderUrl = (params: CreateOrderParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/orders?${stringifiedParams}`
    : `/api/v1/orders`;
};

export const createOrder = async (
  createOrderRequest: CreateOrderRequest,
  params: CreateOrderParams,
  options?: RequestInit
): Promise<createOrderResponse> => {
  return customFetch<createOrderResponse>(getCreateOrderUrl(params), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(createOrderRequest),
  });
};

/**
 * í¼ ë°ì´í„°ë¥¼ í†µí•´ ë‹¤ì–‘í•œ ìœ í˜•ì˜ íŒŒì¼ì„ ì—…ë¡œë“œí•©ë‹ˆë‹¤. fileType íŒŒë¼ë¯¸í„°ë¥¼ í†µí•´ íŒŒì¼ ì €ì¥ ìœ„ì¹˜ë¥¼ ìë™ìœ¼ë¡œ ê²°ì •í•˜ê±°ë‚˜ directory íŒŒë¼ë¯¸í„°ë¡œ ì§ì ‘ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * @deprecated
 * @summary ë‹¨ê±´ íŒŒì¼ ì—…ë¡œë“œ
 */
export type uploadFileResponse201 = {
  data: FileUploadApiResponse;
  status: 201;
};

export type uploadFileResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type uploadFileResponseComposite =
  | uploadFileResponse201
  | uploadFileResponse400;

export type uploadFileResponse = uploadFileResponseComposite & {
  headers: Headers;
};

export const getUploadFileUrl = (params: UploadFileParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/file?${stringifiedParams}`
    : `/api/v1/file`;
};

export const uploadFile = async (
  uploadFileBody: UploadFileBody,
  params: UploadFileParams,
  options?: RequestInit
): Promise<uploadFileResponse> => {
  const formData = new FormData();
  formData.append(`file`, uploadFileBody.file);

  return customFetch<uploadFileResponse>(getUploadFileUrl(params), {
    ...options,
    method: "POST",
    body: formData,
  });
};

/**
 * ì½˜í…ì¸  ìŠ¹ì¸ ë˜ëŠ” ë°˜ë ¤ ì‹¬ì‚¬ë¥¼ ì§„í–‰í•©ë‹ˆë‹¤. [ê´€ë¦¬ì ê¸°ëŠ¥]
 * @deprecated
 * @summary ì½˜í…ì¸  ì‹¬ì‚¬ [ê´€ë¦¬ì ê¸°ëŠ¥]
 */
export type examineContentResponse200 = {
  data: ContentExamineApiResponse;
  status: 200;
};

export type examineContentResponse400 = {
  data: ContentExamineApiResponse;
  status: 400;
};

export type examineContentResponse401 = {
  data: GrobleResponse;
  status: 401;
};

export type examineContentResponseComposite =
  | examineContentResponse200
  | examineContentResponse400
  | examineContentResponse401;

export type examineContentResponse = examineContentResponseComposite & {
  headers: Headers;
};

export const getExamineContentUrl = (contentId: number) => {
  return `/api/v1/content/${contentId}/examine`;
};

export const examineContent = async (
  contentId: number,
  contentExamineRequest: ContentExamineRequest,
  options?: RequestInit
): Promise<examineContentResponse> => {
  return customFetch<examineContentResponse>(getExamineContentUrl(contentId), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(contentExamineRequest),
  });
};

/**
 * ì½˜í…ì¸  ëŒ€í‘œ(ì¸ë„¤ì¼) ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•©ë‹ˆë‹¤. ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•˜ë©°, ë‹¤ë¥¸ íŒŒì¼ í˜•ì‹ì€ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤. ë°˜í™˜ëœ fileUrlì„ ì½˜í…ì¸  ì„ì‹œ ì €ì¥ ë° ì‹¬ì‚¬ ìš”ì²­ì— í¬í•¨í•˜ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * @deprecated
 * @summary ì½˜í…ì¸  ëŒ€í‘œ(ì¸ë„¤ì¼) ì´ë¯¸ì§€ ì—…ë¡œë“œ
 */
export type uploadContentThumbnailResponse201 = {
  data: FileUploadApiResponse;
  status: 201;
};

export type uploadContentThumbnailResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type uploadContentThumbnailResponseComposite =
  | uploadContentThumbnailResponse201
  | uploadContentThumbnailResponse400;

export type uploadContentThumbnailResponse =
  uploadContentThumbnailResponseComposite & {
    headers: Headers;
  };

export const getUploadContentThumbnailUrl = (
  params: UploadContentThumbnailParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/content/thumbnail?${stringifiedParams}`
    : `/api/v1/content/thumbnail`;
};

export const uploadContentThumbnail = async (
  uploadContentThumbnailBody: UploadContentThumbnailBody,
  params: UploadContentThumbnailParams,
  options?: RequestInit
): Promise<uploadContentThumbnailResponse> => {
  const formData = new FormData();
  formData.append(`file`, uploadContentThumbnailBody.file);

  return customFetch<uploadContentThumbnailResponse>(
    getUploadContentThumbnailUrl(params),
    {
      ...options,
      method: "POST",
      body: formData,
    }
  );
};

/**
 * ì½˜í…ì¸  ëŒ€í‘œ(ì¸ë„¤ì¼) ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•©ë‹ˆë‹¤. ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•˜ë©°, ë‹¤ë¥¸ íŒŒì¼ í˜•ì‹ì€ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤. ë°˜í™˜ëœ fileUrlì„ ì½˜í…ì¸  ì„ì‹œ ì €ì¥ ë° ì‹¬ì‚¬ ìš”ì²­ì— í¬í•¨í•˜ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * @summary ì½˜í…ì¸  ëŒ€í‘œ(ì¸ë„¤ì¼) ì´ë¯¸ì§€ ì—…ë¡œë“œ
 */
export type addContentThumbnailImageResponse201 = {
  data: FileUploadApiResponse;
  status: 201;
};

export type addContentThumbnailImageResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type addContentThumbnailImageResponseComposite =
  | addContentThumbnailImageResponse201
  | addContentThumbnailImageResponse400;

export type addContentThumbnailImageResponse =
  addContentThumbnailImageResponseComposite & {
    headers: Headers;
  };

export const getAddContentThumbnailImageUrl = (
  params: AddContentThumbnailImageParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/content/thumbnail/image?${stringifiedParams}`
    : `/api/v1/content/thumbnail/image`;
};

export const addContentThumbnailImage = async (
  addContentThumbnailImageBody: AddContentThumbnailImageBody,
  params: AddContentThumbnailImageParams,
  options?: RequestInit
): Promise<addContentThumbnailImageResponse> => {
  return customFetch<addContentThumbnailImageResponse>(
    getAddContentThumbnailImageUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(addContentThumbnailImageBody),
    }
  );
};

/**
 * ìë£Œ ì½˜í…ì¸  ì¦‰ì‹œ ë‹¤ìš´ë¡œë“œ ì„ íƒ ì‹œ íŒŒì¼ì„ ì—…ë¡œë“œí•©ë‹ˆë‹¤. pdf, zip íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•˜ë©°, ë‹¤ë¥¸ íŒŒì¼ í˜•ì‹ì€ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤. ë°˜í™˜ëœ fileUrlì„ ì½˜í…ì¸  ì„ì‹œ ì €ì¥ ë° ì‹¬ì‚¬ ìš”ì²­ì— í¬í•¨í•˜ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * @summary ìë£Œ ì½˜í…ì¸  ì¦‰ì‹œ ë‹¤ìš´ë¡œë“œ ì„ íƒ ì‹œ íŒŒì¼ ì—…ë¡œë“œ
 */
export type addContentDocumentFileResponse201 = {
  data: FileUploadApiResponse;
  status: 201;
};

export type addContentDocumentFileResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type addContentDocumentFileResponseComposite =
  | addContentDocumentFileResponse201
  | addContentDocumentFileResponse400;

export type addContentDocumentFileResponse =
  addContentDocumentFileResponseComposite & {
    headers: Headers;
  };

export const getAddContentDocumentFileUrl = (
  params: AddContentDocumentFileParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/content/document/upload/file?${stringifiedParams}`
    : `/api/v1/content/document/upload/file`;
};

export const addContentDocumentFile = async (
  addContentDocumentFileBody: AddContentDocumentFileBody,
  params: AddContentDocumentFileParams,
  options?: RequestInit
): Promise<addContentDocumentFileResponse> => {
  return customFetch<addContentDocumentFileResponse>(
    getAddContentDocumentFileUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(addContentDocumentFileBody),
    }
  );
};

/**
 * ì¦‰ì‹œ ë‹¤ìš´ë¡œë“œì— ëŒ€í•œ ì—¬ëŸ¬ ì½˜í…ì¸  íŒŒì¼ì„ í•œ ë²ˆì— ì—…ë¡œë“œí•©ë‹ˆë‹¤. ë¹„ì–´ìˆì§€ ì•Šì€ íŒŒì¼ë§Œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
 * @deprecated
 * @summary ì—¬ëŸ¬ ì½˜í…ì¸  íŒŒì¼ ì—…ë¡œë“œ
 */
export type uploadContentsFilesResponse201 = {
  data: MultipleFilesUploadApiResponse;
  status: 201;
};

export type uploadContentsFilesResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type uploadContentsFilesResponseComposite =
  | uploadContentsFilesResponse201
  | uploadContentsFilesResponse400;

export type uploadContentsFilesResponse =
  uploadContentsFilesResponseComposite & {
    headers: Headers;
  };

export const getUploadContentsFilesUrl = (
  params: UploadContentsFilesParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/content/direct-contents?${stringifiedParams}`
    : `/api/v1/content/direct-contents`;
};

export const uploadContentsFiles = async (
  params: UploadContentsFilesParams,
  options?: RequestInit
): Promise<uploadContentsFilesResponse> => {
  return customFetch<uploadContentsFilesResponse>(
    getUploadContentsFilesUrl(params),
    {
      ...options,
      method: "POST",
    }
  );
};

/**
 * ì—ë””í„°ìš© ì½˜í…ì¸  ìƒì„¸ ì´ë¯¸ì§€ë¥¼ ì—¬ëŸ¬ ê°œ ì—…ë¡œë“œí•©ë‹ˆë‹¤. ì´ë¯¸ì§€ íŒŒì¼ë§Œ í—ˆìš©í•˜ë©°, ë°˜í™˜ëœ URL ë¦¬ìŠ¤íŠ¸ë¥¼ ì—ë””í„°ì— ì‚½ì…í•˜ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * @summary ì½˜í…ì¸  ìƒì„¸ ì´ë¯¸ì§€ ì—…ë¡œë“œ
 */
export type addContentDetailImagesResponse201 = {
  data: MultiFileUploadApiResponse;
  status: 201;
};

export type addContentDetailImagesResponse400 = {
  data: MultiFileUploadApiResponse;
  status: 400;
};

export type addContentDetailImagesResponse401 = {
  data: GrobleResponse;
  status: 401;
};

export type addContentDetailImagesResponseComposite =
  | addContentDetailImagesResponse201
  | addContentDetailImagesResponse400
  | addContentDetailImagesResponse401;

export type addContentDetailImagesResponse =
  addContentDetailImagesResponseComposite & {
    headers: Headers;
  };

export const getAddContentDetailImagesUrl = (
  params: AddContentDetailImagesParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/content/detail/images?${stringifiedParams}`
    : `/api/v1/content/detail/images`;
};

export const addContentDetailImages = async (
  addContentDetailImagesBody: AddContentDetailImagesBody,
  params: AddContentDetailImagesParams,
  options?: RequestInit
): Promise<addContentDetailImagesResponse> => {
  return customFetch<addContentDetailImagesResponse>(
    getAddContentDetailImagesUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(addContentDetailImagesBody),
    }
  );
};

/**
 * ì‚¬ìš©ì ê³„ì •ì„ íƒˆí‡´ ì²˜ë¦¬í•©ë‹ˆë‹¤.
 * @summary íšŒì› íƒˆí‡´
 */
export type withdrawUserResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type withdrawUserResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type withdrawUserResponseComposite =
  | withdrawUserResponse200
  | withdrawUserResponse400;

export type withdrawUserResponse = withdrawUserResponseComposite & {
  headers: Headers;
};

export const getWithdrawUserUrl = (params: WithdrawUserParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/auth/withdrawal?${stringifiedParams}`
    : `/api/v1/auth/withdrawal`;
};

export const withdrawUser = async (
  userWithdrawalRequest: UserWithdrawalRequest,
  params: WithdrawUserParams,
  options?: RequestInit
): Promise<withdrawUserResponse> => {
  return customFetch<withdrawUserResponse>(getWithdrawUserUrl(params), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(userWithdrawalRequest),
  });
};

/**
 * ì´ë©”ì¼ë¡œ ë°œì†¡ëœ ì¸ì¦ ì½”ë“œì˜ ìœ íš¨ì„±ì„ ê²€ì¦í•©ë‹ˆë‹¤.
 * @summary íšŒì›ê°€ì… ì‹œ ì´ë©”ì¼ ì¸ì¦ ì½”ë“œ í™•ì¸
 */
export type verifyEmailCodeResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type verifyEmailCodeResponseComposite = verifyEmailCodeResponse200;

export type verifyEmailCodeResponse = verifyEmailCodeResponseComposite & {
  headers: Headers;
};

export const getVerifyEmailCodeUrl = () => {
  return `/api/v1/auth/verify-code/sign-up`;
};

export const verifyEmailCode = async (
  verifyEmailCodeRequest: VerifyEmailCodeRequest,
  options?: RequestInit
): Promise<verifyEmailCodeResponse> => {
  return customFetch<verifyEmailCodeResponse>(getVerifyEmailCodeUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(verifyEmailCodeRequest),
  });
};

/**
 * ì´ë©”ì¼ ë³€ê²½ ì‹œ ì¸ì¦ ì½”ë“œì˜ ìœ íš¨ì„±ì„ ê²€ì¦í•˜ê³  ì´ë©”ì¼ì„ ë³€ê²½í•©ë‹ˆë‹¤.
 * @summary ì´ë©”ì¼ ë³€ê²½ ì‹œ ì´ë©”ì¼ ì¸ì¦ ì½”ë“œ í™•ì¸
 */
export type verifyEmailCodeForChangeEmailResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type verifyEmailCodeForChangeEmailResponseComposite =
  verifyEmailCodeForChangeEmailResponse200;

export type verifyEmailCodeForChangeEmailResponse =
  verifyEmailCodeForChangeEmailResponseComposite & {
    headers: Headers;
  };

export const getVerifyEmailCodeForChangeEmailUrl = (
  params: VerifyEmailCodeForChangeEmailParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/auth/verify-code/change-email?${stringifiedParams}`
    : `/api/v1/auth/verify-code/change-email`;
};

export const verifyEmailCodeForChangeEmail = async (
  verifyEmailCodeRequest: VerifyEmailCodeRequest,
  params: VerifyEmailCodeForChangeEmailParams,
  options?: RequestInit
): Promise<verifyEmailCodeForChangeEmailResponse> => {
  return customFetch<verifyEmailCodeForChangeEmailResponse>(
    getVerifyEmailCodeForChangeEmailUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(verifyEmailCodeRequest),
    }
  );
};

/**
 * í˜„ì¬ ì‚¬ìš©ìì˜ ì¸ì¦ í† í°ì„ ê²€ì¦í•˜ê³  ë¡œê·¸ì¸ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
 * @deprecated
 * @summary í† í° ê²€ì¦
 */
export type validateTokenResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type validateTokenResponseComposite = validateTokenResponse200;

export type validateTokenResponse = validateTokenResponseComposite & {
  headers: Headers;
};

export const getValidateTokenUrl = (params: ValidateTokenParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/auth/validate-token?${stringifiedParams}`
    : `/api/v1/auth/validate-token`;
};

export const validateToken = async (
  params: ValidateTokenParams,
  options?: RequestInit
): Promise<validateTokenResponse> => {
  return customFetch<validateTokenResponse>(getValidateTokenUrl(params), {
    ...options,
    method: "POST",
  });
};

/**
 * ë‹‰ë„¤ì„ì„ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * @summary ë‹‰ë„¤ì„ ìˆ˜ì •
 */
export type updateNicknameResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type updateNicknameResponse401 = {
  data: GrobleResponse;
  status: 401;
};

export type updateNicknameResponseComposite =
  | updateNicknameResponse200
  | updateNicknameResponse401;

export type updateNicknameResponse = updateNicknameResponseComposite & {
  headers: Headers;
};

export const getUpdateNicknameUrl = (params: UpdateNicknameParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/auth/users/nickname?${stringifiedParams}`
    : `/api/v1/auth/users/nickname`;
};

export const updateNickname = async (
  nicknameRequest: NicknameRequest,
  params: UpdateNicknameParams,
  options?: RequestInit
): Promise<updateNicknameResponse> => {
  return customFetch<updateNicknameResponse>(getUpdateNicknameUrl(params), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(nicknameRequest),
  });
};

/**
 * ìƒˆë¡œìš´ ì‚¬ìš©ìë¥¼ ë“±ë¡í•˜ê³  ì¸ì¦ í† í°ì„ ë°œê¸‰í•©ë‹ˆë‹¤.
 * @summary íšŒì›ê°€ì…
 */
export type signUpResponse201 = {
  data: SignUpApiResponse;
  status: 201;
};

export type signUpResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type signUpResponseComposite = signUpResponse201 | signUpResponse400;

export type signUpResponse = signUpResponseComposite & {
  headers: Headers;
};

export const getSignUpUrl = () => {
  return `/api/v1/auth/sign-up`;
};

export const signUp = async (
  signUpRequest: SignUpRequest,
  options?: RequestInit
): Promise<signUpResponse> => {
  return customFetch<signUpResponse>(getSignUpUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(signUpRequest),
  });
};

/**
 * ì†Œì…œ íšŒì›ê°€ì…ì˜ ê¸°ë³¸ ì •ë³´ë¥¼ ë“±ë¡í•˜ê³  í† í°ì„ ë°œê¸‰í•©ë‹ˆë‹¤.
 * @summary ì†Œì…œ íšŒì›ê°€ì…
 */
export type signUpSocialResponse201 = {
  data: SignUpApiResponse;
  status: 201;
};

export type signUpSocialResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type signUpSocialResponseComposite =
  | signUpSocialResponse201
  | signUpSocialResponse400;

export type signUpSocialResponse = signUpSocialResponseComposite & {
  headers: Headers;
};

export const getSignUpSocialUrl = (params: SignUpSocialParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/auth/sign-up/social?${stringifiedParams}`
    : `/api/v1/auth/sign-up/social`;
};

export const signUpSocial = async (
  socialSignUpRequest: SocialSignUpRequest,
  params: SignUpSocialParams,
  options?: RequestInit
): Promise<signUpSocialResponse> => {
  return customFetch<signUpSocialResponse>(getSignUpSocialUrl(params), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(socialSignUpRequest),
  });
};

/**
 * ì´ë©”ì¼ê³¼ ë¹„ë°€ë²ˆí˜¸ë¡œ ë¡œê·¸ì¸í•˜ê³  ì¸ì¦ í† í°ì„ ë°œê¸‰í•©ë‹ˆë‹¤.
 * @summary ë¡œê·¸ì¸
 */
export type signInResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type signInResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type signInResponseComposite = signInResponse200 | signInResponse400;

export type signInResponse = signInResponseComposite & {
  headers: Headers;
};

export const getSignInUrl = () => {
  return `/api/v1/auth/sign-in`;
};

export const signIn = async (
  signInRequest: SignInRequest,
  options?: RequestInit
): Promise<signInResponse> => {
  return customFetch<signInResponse>(getSignInUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(signInRequest),
  });
};

/**
 * ì´ë©”ì¼ê³¼ ë¹„ë°€ë²ˆí˜¸ë¡œ ë¡œê·¸ì¸í•˜ê³  ì¸ì¦ í† í°ì„ ë°œê¸‰í•©ë‹ˆë‹¤.
 * @summary ë¡œê·¸ì¸
 */
export type signInTestResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type signInTestResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type signInTestResponseComposite =
  | signInTestResponse200
  | signInTestResponse400;

export type signInTestResponse = signInTestResponseComposite & {
  headers: Headers;
};

export const getSignInTestUrl = () => {
  return `/api/v1/auth/sign-in/local/test`;
};

export const signInTest = async (
  signInRequest: SignInRequest,
  options?: RequestInit
): Promise<signInTestResponse> => {
  return customFetch<signInTestResponse>(getSignInTestUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(signInRequest),
  });
};

/**
 * ë¦¬í”„ë ˆì‹œ í† í°ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆë¡œìš´ ì•¡ì„¸ìŠ¤ í† í°ì„ ë°œê¸‰í•©ë‹ˆë‹¤.
 * @deprecated
 * @summary accessToken ì¬ë°œê¸‰
 */
export type refreshTokenResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type refreshTokenResponseComposite = refreshTokenResponse200;

export type refreshTokenResponse = refreshTokenResponseComposite & {
  headers: Headers;
};

export const getRefreshTokenUrl = () => {
  return `/api/v1/auth/refresh-token`;
};

export const refreshToken = async (
  options?: RequestInit
): Promise<refreshTokenResponse> => {
  return customFetch<refreshTokenResponse>(getRefreshTokenUrl(), {
    ...options,
    method: "POST",
  });
};

/**
 * ì „í™”ë²ˆí˜¸ ì¸ì¦ ì½”ë“œë¥¼ ë°œì†¡í•©ë‹ˆë‹¤.
 * @summary ì „í™”ë²ˆí˜¸ ì¸ì¦ ìš”ì²­
 */
export type authPhoneNumberResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type authPhoneNumberResponseComposite = authPhoneNumberResponse200;

export type authPhoneNumberResponse = authPhoneNumberResponseComposite & {
  headers: Headers;
};

export const getAuthPhoneNumberUrl = (params: AuthPhoneNumberParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/auth/phone-number/verify-request?${stringifiedParams}`
    : `/api/v1/auth/phone-number/verify-request`;
};

export const authPhoneNumber = async (
  phoneNumberVerifyRequest: PhoneNumberVerifyRequest,
  params: AuthPhoneNumberParams,
  options?: RequestInit
): Promise<authPhoneNumberResponse> => {
  return customFetch<authPhoneNumberResponse>(getAuthPhoneNumberUrl(params), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(phoneNumberVerifyRequest),
  });
};

/**
 * ì „í™”ë²ˆí˜¸ë¡œ ë°œì†¡ëœ ì¸ì¦ ì½”ë“œë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.
 * @summary ì „í™”ë²ˆí˜¸ ì¸ì¦ ì½”ë“œ ê²€ì¦
 */
export type verifyPhoneNumberResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type verifyPhoneNumberResponseComposite = verifyPhoneNumberResponse200;

export type verifyPhoneNumberResponse = verifyPhoneNumberResponseComposite & {
  headers: Headers;
};

export const getVerifyPhoneNumberUrl = (params: VerifyPhoneNumberParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/auth/phone-number/verify-code?${stringifiedParams}`
    : `/api/v1/auth/phone-number/verify-code`;
};

export const verifyPhoneNumber = async (
  phoneNumberVerifyCodeRequest: PhoneNumberVerifyCodeRequest,
  params: VerifyPhoneNumberParams,
  options?: RequestInit
): Promise<verifyPhoneNumberResponse> => {
  return customFetch<verifyPhoneNumberResponse>(
    getVerifyPhoneNumberUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(phoneNumberVerifyCodeRequest),
    }
  );
};

/**
 * ìƒˆë¡œìš´ ë¹„ë°€ë²ˆí˜¸ë¡œ ì¬ì„¤ì •í•©ë‹ˆë‹¤.
 * @summary ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •
 */
export type resetPasswordResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type resetPasswordResponseComposite = resetPasswordResponse200;

export type resetPasswordResponse = resetPasswordResponseComposite & {
  headers: Headers;
};

export const getResetPasswordUrl = () => {
  return `/api/v1/auth/password/reset`;
};

export const resetPassword = async (
  resetPasswordRequest: ResetPasswordRequest,
  options?: RequestInit
): Promise<resetPasswordResponse> => {
  return customFetch<resetPasswordResponse>(getResetPasswordUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(resetPasswordRequest),
  });
};

/**
 * ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ë§í¬ê°€ í¬í•¨ëœ ì´ë©”ì¼ì„ ë°œì†¡í•©ë‹ˆë‹¤.
 * @summary ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ì´ë©”ì¼ ë°œì†¡
 */
export type requestPasswordResetResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type requestPasswordResetResponseComposite =
  requestPasswordResetResponse200;

export type requestPasswordResetResponse =
  requestPasswordResetResponseComposite & {
    headers: Headers;
  };

export const getRequestPasswordResetUrl = () => {
  return `/api/v1/auth/password/reset-request`;
};

export const requestPasswordReset = async (
  emailVerificationRequest: EmailVerificationRequest,
  options?: RequestInit
): Promise<requestPasswordResetResponse> => {
  return customFetch<requestPasswordResetResponse>(
    getRequestPasswordResetUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(emailVerificationRequest),
    }
  );
};

/**
 * ë¡œê·¸ì•„ì›ƒì„ í†µí•´ ì¿ í‚¤ì™€ í† í°ì„ ë¬´íš¨í™”í•©ë‹ˆë‹¤.
 * @summary ë¡œê·¸ì•„ì›ƒ
 */
export type logoutResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type logoutResponseComposite = logoutResponse200;

export type logoutResponse = logoutResponseComposite & {
  headers: Headers;
};

export const getLogoutUrl = (params: LogoutParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/auth/logout?${stringifiedParams}`
    : `/api/v1/auth/logout`;
};

export const logout = async (
  params: LogoutParams,
  options?: RequestInit
): Promise<logoutResponse> => {
  return customFetch<logoutResponse>(getLogoutUrl(params), {
    ...options,
    method: "POST",
  });
};

/**
 * íšŒì›ê°€ì… ì‹œ íŒë§¤ì ë˜ëŠ” êµ¬ë§¤ì ì¤‘ ì„ íƒí•©ë‹ˆë‹¤.
 * @deprecated
 * @summary íšŒì›ê°€ì… ìœ í˜• ì„ íƒ
 */
export type setInitialUserTypeResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type setInitialUserTypeResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type setInitialUserTypeResponseComposite =
  | setInitialUserTypeResponse200
  | setInitialUserTypeResponse400;

export type setInitialUserTypeResponse = setInitialUserTypeResponseComposite & {
  headers: Headers;
};

export const getSetInitialUserTypeUrl = (params: SetInitialUserTypeParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/auth/initial-user-type?${stringifiedParams}`
    : `/api/v1/auth/initial-user-type`;
};

export const setInitialUserType = async (
  userTypeRequest: UserTypeRequest,
  params: SetInitialUserTypeParams,
  options?: RequestInit
): Promise<setInitialUserTypeResponse> => {
  return customFetch<setInitialUserTypeResponse>(
    getSetInitialUserTypeUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(userTypeRequest),
    }
  );
};

/**
 * ì‚¬ìš©ìê°€ ê¸°ì…í•œ ì´ë©”ì¼ì— ì¸ì¦ ì½”ë“œë¥¼ ë°œê¸‰í•©ë‹ˆë‹¤.
 * @summary í†µí•© íšŒì›ê°€ì… ì´ë©”ì¼ ì¸ì¦ ìš”ì²­
 */
export type sendEmailVerificationForSignUpResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type sendEmailVerificationForSignUpResponseComposite =
  sendEmailVerificationForSignUpResponse200;

export type sendEmailVerificationForSignUpResponse =
  sendEmailVerificationForSignUpResponseComposite & {
    headers: Headers;
  };

export const getSendEmailVerificationForSignUpUrl = () => {
  return `/api/v1/auth/email-verification/sign-up`;
};

export const sendEmailVerificationForSignUp = async (
  emailVerificationRequest: EmailVerificationRequest,
  options?: RequestInit
): Promise<sendEmailVerificationForSignUpResponse> => {
  return customFetch<sendEmailVerificationForSignUpResponse>(
    getSendEmailVerificationForSignUpUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(emailVerificationRequest),
    }
  );
};

/**
 * ì‚¬ìš©ìê°€ ê¸°ì…í•œ ì´ë©”ì¼ì— ì¸ì¦ ì½”ë“œë¥¼ ë°œê¸‰í•©ë‹ˆë‹¤.
 * @summary ì´ë©”ì¼ ë³€ê²½ ì´ë©”ì¼ ì¸ì¦ ìš”ì²­
 */
export type sendEmailVerificationForChangeEmailResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type sendEmailVerificationForChangeEmailResponseComposite =
  sendEmailVerificationForChangeEmailResponse200;

export type sendEmailVerificationForChangeEmailResponse =
  sendEmailVerificationForChangeEmailResponseComposite & {
    headers: Headers;
  };

export const getSendEmailVerificationForChangeEmailUrl = (
  params: SendEmailVerificationForChangeEmailParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/auth/email-verification/change-email?${stringifiedParams}`
    : `/api/v1/auth/email-verification/change-email`;
};

export const sendEmailVerificationForChangeEmail = async (
  emailVerificationRequest: EmailVerificationRequest,
  params: SendEmailVerificationForChangeEmailParams,
  options?: RequestInit
): Promise<sendEmailVerificationForChangeEmailResponse> => {
  return customFetch<sendEmailVerificationForChangeEmailResponse>(
    getSendEmailVerificationForChangeEmailUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(emailVerificationRequest),
    }
  );
};

/**
 * ë§ˆì´í˜ì´ì§€ ì²« í™”ë©´ì—ì„œ ìš”ì•½ ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤. ì‚¬ìš©ì ìœ í˜•(êµ¬ë§¤ì/íŒë§¤ì)ì— ë”°ë¼ ì‘ë‹µ êµ¬ì¡°ê°€ ë‹¬ë¼ì§‘ë‹ˆë‹¤.
 * @summary ë§ˆì´í˜ì´ì§€ ìš”ì•½ ì •ë³´ ì¡°íšŒ
 */
export type getUserMyPageSummaryResponse200 = {
  data: UserMyPageSummaryApiResponse;
  status: 200;
};

export type getUserMyPageSummaryResponse401 = {
  data: GrobleResponse;
  status: 401;
};

export type getUserMyPageSummaryResponseComposite =
  | getUserMyPageSummaryResponse200
  | getUserMyPageSummaryResponse401;

export type getUserMyPageSummaryResponse =
  getUserMyPageSummaryResponseComposite & {
    headers: Headers;
  };

export const getGetUserMyPageSummaryUrl = (
  params: GetUserMyPageSummaryParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/me/summary?${stringifiedParams}`
    : `/api/v1/me/summary`;
};

export const getUserMyPageSummary = async (
  params: GetUserMyPageSummaryParams,
  options?: RequestInit
): Promise<getUserMyPageSummaryResponse> => {
  return customFetch<getUserMyPageSummaryResponse>(
    getGetUserMyPageSummaryUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

/**
 * ë§ˆì´í˜ì´ì§€ì—ì„œ ì‚¬ìš©ì ìƒì„¸ ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ë§ˆì´í˜ì´ì§€ ìƒì„¸ ì •ë³´ ì¡°íšŒ
 */
export type getUserMyPageDetailResponse200 = {
  data: UserMyPageDetailApiResponse;
  status: 200;
};

export type getUserMyPageDetailResponse401 = {
  data: GrobleResponse;
  status: 401;
};

export type getUserMyPageDetailResponseComposite =
  | getUserMyPageDetailResponse200
  | getUserMyPageDetailResponse401;

export type getUserMyPageDetailResponse =
  getUserMyPageDetailResponseComposite & {
    headers: Headers;
  };

export const getGetUserMyPageDetailUrl = (
  params: GetUserMyPageDetailParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/me/detail?${stringifiedParams}`
    : `/api/v1/me/detail`;
};

export const getUserMyPageDetail = async (
  params: GetUserMyPageDetailParams,
  options?: RequestInit
): Promise<getUserMyPageDetailResponse> => {
  return customFetch<getUserMyPageDetailResponse>(
    getGetUserMyPageDetailUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

/**
 * ì‚¬ìš©ìì˜ ì•½ê´€ ë™ì˜ ìƒíƒœë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì‚¬ìš©ì ì•½ê´€ ë™ì˜ ìƒíƒœ ì¡°íšŒ
 */
export type getUserTermsAgreementsResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type getUserTermsAgreementsResponseComposite =
  getUserTermsAgreementsResponse200;

export type getUserTermsAgreementsResponse =
  getUserTermsAgreementsResponseComposite & {
    headers: Headers;
  };

export const getGetUserTermsAgreementsUrl = (
  params: GetUserTermsAgreementsParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/terms/user?${stringifiedParams}`
    : `/api/v1/terms/user`;
};

export const getUserTermsAgreements = async (
  params: GetUserTermsAgreementsParams,
  options?: RequestInit
): Promise<getUserTermsAgreementsResponse> => {
  return customFetch<getUserTermsAgreementsResponse>(
    getGetUserTermsAgreementsUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

/**
 * í˜„ì¬ ìœ íš¨í•œ ìµœì‹  ë²„ì „ì˜ ì•½ê´€ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary í˜„ì¬ ìœ íš¨í•œ ì•½ê´€ ëª©ë¡ ì¡°íšŒ
 */
export type getActiveTermsResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type getActiveTermsResponseComposite = getActiveTermsResponse200;

export type getActiveTermsResponse = getActiveTermsResponseComposite & {
  headers: Headers;
};

export const getGetActiveTermsUrl = () => {
  return `/api/v1/terms/active`;
};

export const getActiveTerms = async (
  options?: RequestInit
): Promise<getActiveTermsResponse> => {
  return customFetch<getActiveTermsResponse>(getGetActiveTermsUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * ì‹¬ì‚¬ ê±°ì ˆëœ ì½˜í…ì¸ ì˜ ê±°ì ˆ ì‚¬ìœ ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì½˜í…ì¸  ì‹¬ì‚¬ ê±°ì ˆ ì‚¬ìœ  ì¡°íšŒ
 */
export type getExamineRejectReasonResponse200 = {
  data: ContentExamineRejectApiResponse;
  status: 200;
};

export type getExamineRejectReasonResponse401 = {
  data: GrobleResponse;
  status: 401;
};

export type getExamineRejectReasonResponseComposite =
  | getExamineRejectReasonResponse200
  | getExamineRejectReasonResponse401;

export type getExamineRejectReasonResponse =
  getExamineRejectReasonResponseComposite & {
    headers: Headers;
  };

export const getGetExamineRejectReasonUrl = (
  contentId: number,
  params: GetExamineRejectReasonParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/sell/content/${contentId}/examine/reject?${stringifiedParams}`
    : `/api/v1/sell/content/${contentId}/examine/reject`;
};

export const getExamineRejectReason = async (
  contentId: number,
  params: GetExamineRejectReasonParams,
  options?: RequestInit
): Promise<getExamineRejectReasonResponse> => {
  return customFetch<getExamineRejectReasonResponse>(
    getGetExamineRejectReasonUrl(contentId, params),
    {
      ...options,
      method: "GET",
    }
  );
};

/**
 * ë‚˜ì˜ ì„œë¹„ìŠ¤ ë˜ëŠ” ìë£Œ ì½˜í…ì¸ ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ë‚˜ì˜ íŒë§¤ ì½˜í…ì¸  ì¡°íšŒ
 */
export type getMySellingContentsResponse200 = {
  data: MySellingContentsApiResponse;
  status: 200;
};

export type getMySellingContentsResponse401 = {
  data: GrobleResponse;
  status: 401;
};

export type getMySellingContentsResponseComposite =
  | getMySellingContentsResponse200
  | getMySellingContentsResponse401;

export type getMySellingContentsResponse =
  getMySellingContentsResponseComposite & {
    headers: Headers;
  };

export const getGetMySellingContentsUrl = (
  params: GetMySellingContentsParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/sell/content/my/selling-contents?${stringifiedParams}`
    : `/api/v1/sell/content/my/selling-contents`;
};

export const getMySellingContents = async (
  params: GetMySellingContentsParams,
  options?: RequestInit
): Promise<getMySellingContentsResponse> => {
  return customFetch<getMySellingContentsResponse>(
    getGetMySellingContentsUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

/**
 * ë‚´ê°€ ìŠ¤í¬ë©í•œ ì½˜í…ì¸ ë“¤ì„ ì»¤ì„œ ê¸°ë°˜ í˜ì´ì§€ë„¤ì´ì…˜ìœ¼ë¡œ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ë‚´ê°€ ìŠ¤í¬ë©í•œ ì½˜í…ì¸  ì¡°íšŒ
 */
export type getMyScrapContentsResponse200 = {
  data: ContentScrapCardApiResponse;
  status: 200;
};

export type getMyScrapContentsResponse401 = {
  data: GrobleResponse;
  status: 401;
};

export type getMyScrapContentsResponseComposite =
  | getMyScrapContentsResponse200
  | getMyScrapContentsResponse401;

export type getMyScrapContentsResponse = getMyScrapContentsResponseComposite & {
  headers: Headers;
};

export const getGetMyScrapContentsUrl = (params: GetMyScrapContentsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/scrap/contents?${stringifiedParams}`
    : `/api/v1/scrap/contents`;
};

export const getMyScrapContents = async (
  params: GetMyScrapContentsParams,
  options?: RequestInit
): Promise<getMyScrapContentsResponse> => {
  return customFetch<getMyScrapContentsResponse>(
    getGetMyScrapContentsUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

/**
 * @deprecated
 */
export type getMyPurchasingContentsResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type getMyPurchasingContentsResponseComposite =
  getMyPurchasingContentsResponse200;

export type getMyPurchasingContentsResponse =
  getMyPurchasingContentsResponseComposite & {
    headers: Headers;
  };

export const getGetMyPurchasingContentsUrl = (
  params: GetMyPurchasingContentsParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/purchase/contents/my?${stringifiedParams}`
    : `/api/v1/purchase/contents/my`;
};

export const getMyPurchasingContents = async (
  params: GetMyPurchasingContentsParams,
  options?: RequestInit
): Promise<getMyPurchasingContentsResponse> => {
  return customFetch<getMyPurchasingContentsResponse>(
    getGetMyPurchasingContentsUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

/**
 * ì†Œì…œ ë¡œê·¸ì¸ ì‹œì‘ ì „ ë¦¬ë‹¤ì´ë ‰íŠ¸ URIë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
 * @summary OAuth2 ë¡œê·¸ì¸ ì‹œì‘
 */
export type authorizeResponse200 = {
  data: void;
  status: 200;
};

export type authorizeResponseComposite = authorizeResponse200;

export type authorizeResponse = authorizeResponseComposite & {
  headers: Headers;
};

export const getAuthorizeUrl = (params: AuthorizeParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/oauth2/authorize?${stringifiedParams}`
    : `/api/v1/oauth2/authorize`;
};

export const authorize = async (
  params: AuthorizeParams,
  options?: RequestInit
): Promise<authorizeResponse> => {
  return customFetch<authorizeResponse>(getAuthorizeUrl(params), {
    ...options,
    method: "GET",
  });
};

/**
 * ì‚¬ìš©ìì˜ ëª¨ë“  ì•Œë¦¼ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì•Œë¦¼ ì „ì²´ ì¡°íšŒ
 */
export type getNotificationsResponse200 = {
  data: NotificationItemsApiResponse;
  status: 200;
};

export type getNotificationsResponse401 = {
  data: GrobleResponse;
  status: 401;
};

export type getNotificationsResponseComposite =
  | getNotificationsResponse200
  | getNotificationsResponse401;

export type getNotificationsResponse = getNotificationsResponseComposite & {
  headers: Headers;
};

export const getGetNotificationsUrl = () => {
  return `/api/v1/notifications`;
};

export const getNotifications = async (
  options?: RequestInit
): Promise<getNotificationsResponse> => {
  return customFetch<getNotificationsResponse>(getGetNotificationsUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * ì‚¬ìš©ìì˜ ëª¨ë“  ì•Œë¦¼ì„ ì‚­ì œí•©ë‹ˆë‹¤.
 * @summary ì•Œë¦¼ ì „ì²´ ì‚­ì œ
 */
export type deleteAllNotificationsResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type deleteAllNotificationsResponse401 = {
  data: GrobleResponse;
  status: 401;
};

export type deleteAllNotificationsResponseComposite =
  | deleteAllNotificationsResponse200
  | deleteAllNotificationsResponse401;

export type deleteAllNotificationsResponse =
  deleteAllNotificationsResponseComposite & {
    headers: Headers;
  };

export const getDeleteAllNotificationsUrl = () => {
  return `/api/v1/notifications`;
};

export const deleteAllNotifications = async (
  options?: RequestInit
): Promise<deleteAllNotificationsResponse> => {
  return customFetch<deleteAllNotificationsResponse>(
    getDeleteAllNotificationsUrl(),
    {
      ...options,
      method: "DELETE",
    }
  );
};

/**
 * í™ˆí™”ë©´ì— í‘œì‹œë  ì‚¬ìš©ì í—¤ë” ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤. ë¡œê·¸ì¸ ìƒíƒœ ì—¬ë¶€ì— ê´€ê³„ì—†ì´ ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
 * @summary í™ˆí™”ë©´ í—¤ë” ì •ë³´ ì¡°íšŒ
 */
export type getUserHeaderInformResponse200 = {
  data: UserHeaderApiResponse;
  status: 200;
};

export type getUserHeaderInformResponse500 = {
  data: GrobleResponse;
  status: 500;
};

export type getUserHeaderInformResponseComposite =
  | getUserHeaderInformResponse200
  | getUserHeaderInformResponse500;

export type getUserHeaderInformResponse =
  getUserHeaderInformResponseComposite & {
    headers: Headers;
  };

export const getGetUserHeaderInformUrl = (
  params: GetUserHeaderInformParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/me?${stringifiedParams}`
    : `/api/v1/me`;
};

export const getUserHeaderInform = async (
  params: GetUserHeaderInformParams,
  options?: RequestInit
): Promise<getUserHeaderInformResponse> => {
  return customFetch<getUserHeaderInformResponse>(
    getGetUserHeaderInformUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

/**
 * í™ˆí™”ë©´ì— í‘œì‹œí•  ì½˜í…ì¸  ëª©ë¡ì„ íƒ€ì…ë³„ë¡œ ì¡°íšŒí•©ë‹ˆë‹¤. [ì„œë¹„ìŠ¤ ë˜ëŠ” ìë£Œ]
 * @summary í™ˆí™”ë©´ ì½˜í…ì¸  ëª©ë¡ ì¡°íšŒ
 */
export type getHomeContentsResponse200 = {
  data: HomeContentsApiResponse;
  status: 200;
};

export type getHomeContentsResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type getHomeContentsResponseComposite =
  | getHomeContentsResponse200
  | getHomeContentsResponse400;

export type getHomeContentsResponse = getHomeContentsResponseComposite & {
  headers: Headers;
};

export const getGetHomeContentsUrl = () => {
  return `/api/v1/home/contents`;
};

export const getHomeContents = async (
  options?: RequestInit
): Promise<getHomeContentsResponse> => {
  return customFetch<getHomeContentsResponse>(getGetHomeContentsUrl(), {
    ...options,
    method: "GET",
  });
};

export type getDynamicContentListResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type getDynamicContentListResponseComposite =
  getDynamicContentListResponse200;

export type getDynamicContentListResponse =
  getDynamicContentListResponseComposite & {
    headers: Headers;
  };

export const getGetDynamicContentListUrl = () => {
  return `/api/v1/groble/contents`;
};

export const getDynamicContentList = async (
  options?: RequestInit
): Promise<getDynamicContentListResponse> => {
  return customFetch<getDynamicContentListResponse>(
    getGetDynamicContentListUrl(),
    {
      ...options,
      method: "GET",
    }
  );
};

/**
 * ì¹´í…Œê³ ë¦¬ IDë¡œ í˜ì´ì§€ ë²ˆí˜¸ ê¸°ë°˜ìœ¼ë¡œ ì½˜í…ì¸ ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤. ë°˜í™˜ë˜ëŠ” `items` ë°°ì—´ì˜ ìš”ì†ŒëŠ” ContentPreviewCardResponse ì…ë‹ˆë‹¤.
 * @summary ì¹´í…Œê³ ë¦¬ë³„ ìë£Œ ì½˜í…ì¸  ì¡°íšŒ
 */
export type getDocumentContentsByCategoryResponse200 = {
  data: ContentsCategoryApiResponse;
  status: 200;
};

export type getDocumentContentsByCategoryResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type getDocumentContentsByCategoryResponseComposite =
  | getDocumentContentsByCategoryResponse200
  | getDocumentContentsByCategoryResponse400;

export type getDocumentContentsByCategoryResponse =
  getDocumentContentsByCategoryResponseComposite & {
    headers: Headers;
  };

export const getGetDocumentContentsByCategoryUrl = (
  params?: GetDocumentContentsByCategoryParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/contents/document/category?${stringifiedParams}`
    : `/api/v1/contents/document/category`;
};

export const getDocumentContentsByCategory = async (
  params?: GetDocumentContentsByCategoryParams,
  options?: RequestInit
): Promise<getDocumentContentsByCategoryResponse> => {
  return customFetch<getDocumentContentsByCategoryResponse>(
    getGetDocumentContentsByCategoryUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

/**
 * ì¹´í…Œê³ ë¦¬ IDë¡œ í˜ì´ì§€ ë²ˆí˜¸ ê¸°ë°˜ìœ¼ë¡œ ì½˜í…ì¸ ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤. ë°˜í™˜ë˜ëŠ” `items` ë°°ì—´ì˜ ìš”ì†ŒëŠ” ContentPreviewCardResponse ì…ë‹ˆë‹¤.
 * @summary ì¹´í…Œê³ ë¦¬ë³„ ì½˜í…ì¸  ì¡°íšŒ
 */
export type getCoachingContentsByCategoryResponse200 = {
  data: ContentsCategoryApiResponse;
  status: 200;
};

export type getCoachingContentsByCategoryResponse400 = {
  data: GrobleResponse;
  status: 400;
};

export type getCoachingContentsByCategoryResponseComposite =
  | getCoachingContentsByCategoryResponse200
  | getCoachingContentsByCategoryResponse400;

export type getCoachingContentsByCategoryResponse =
  getCoachingContentsByCategoryResponseComposite & {
    headers: Headers;
  };

export const getGetCoachingContentsByCategoryUrl = (
  params?: GetCoachingContentsByCategoryParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/contents/coaching/category?${stringifiedParams}`
    : `/api/v1/contents/coaching/category`;
};

export const getCoachingContentsByCategory = async (
  params?: GetCoachingContentsByCategoryParams,
  options?: RequestInit
): Promise<getCoachingContentsByCategoryResponse> => {
  return customFetch<getCoachingContentsByCategoryResponse>(
    getGetCoachingContentsByCategoryUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

/**
 * ì½˜í…ì¸  ìƒì„¸ ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤. [ì„œë¹„ìŠ¤ & ìë£Œ]
 * @summary ì½˜í…ì¸  ìƒì„¸ ì •ë³´ ì¡°íšŒ
 */
export type getContentDetailResponse200 = {
  data: ContentDetailApiResponse;
  status: 200;
};

export type getContentDetailResponse401 = {
  data: GrobleResponse;
  status: 401;
};

export type getContentDetailResponseComposite =
  | getContentDetailResponse200
  | getContentDetailResponse401;

export type getContentDetailResponse = getContentDetailResponseComposite & {
  headers: Headers;
};

export const getGetContentDetailUrl = (
  contentId: number,
  params: GetContentDetailParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/content/${contentId}?${stringifiedParams}`
    : `/api/v1/content/${contentId}`;
};

export const getContentDetail = async (
  contentId: number,
  params: GetContentDetailParams,
  options?: RequestInit
): Promise<getContentDetailResponse> => {
  return customFetch<getContentDetailResponse>(
    getGetContentDetailUrl(contentId, params),
    {
      ...options,
      method: "GET",
    }
  );
};

/**
 * ë‹‰ë„¤ì„ì´ ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤. íšŒì›ê°€ì… ë° ë‹‰ë„¤ì„ ìˆ˜ì • ì‹œ ì‚¬ìš©ë©ë‹ˆë‹¤.
 * @summary ë‹‰ë„¤ì„ ì¤‘ë³µ í™•ì¸
 */
export type checkNicknameDuplicateResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type checkNicknameDuplicateResponse401 = {
  data: GrobleResponse;
  status: 401;
};

export type checkNicknameDuplicateResponseComposite =
  | checkNicknameDuplicateResponse200
  | checkNicknameDuplicateResponse401;

export type checkNicknameDuplicateResponse =
  checkNicknameDuplicateResponseComposite & {
    headers: Headers;
  };

export const getCheckNicknameDuplicateUrl = (
  params: CheckNicknameDuplicateParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/auth/nickname/check?${stringifiedParams}`
    : `/api/v1/auth/nickname/check`;
};

export const checkNicknameDuplicate = async (
  params: CheckNicknameDuplicateParams,
  options?: RequestInit
): Promise<checkNicknameDuplicateResponse> => {
  return customFetch<checkNicknameDuplicateResponse>(
    getCheckNicknameDuplicateUrl(params),
    {
      ...options,
      method: "GET",
    }
  );
};

/**
 * íŠ¹ì • ì•Œë¦¼ì„ ì‚­ì œí•©ë‹ˆë‹¤.
 * @summary ì•Œë¦¼ ë‹¨ì¼ ì‚­ì œ
 */
export type deleteNotificationResponse200 = {
  data: GrobleResponse;
  status: 200;
};

export type deleteNotificationResponse401 = {
  data: GrobleResponse;
  status: 401;
};

export type deleteNotificationResponseComposite =
  | deleteNotificationResponse200
  | deleteNotificationResponse401;

export type deleteNotificationResponse = deleteNotificationResponseComposite & {
  headers: Headers;
};

export const getDeleteNotificationUrl = (notificationId: number) => {
  return `/api/v1/notifications/${notificationId}`;
};

export const deleteNotification = async (
  notificationId: number,
  options?: RequestInit
): Promise<deleteNotificationResponse> => {
  return customFetch<deleteNotificationResponse>(
    getDeleteNotificationUrl(notificationId),
    {
      ...options,
      method: "DELETE",
    }
  );
};
